#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using System;
using System.Collections.Immutable;

namespace Skugga.Generator
{
    [Generator]
    public class SkuggaGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is InvocationExpressionSyntax,
                transform: (ctx, _) => GetTarget(ctx)
            ).Where(m => m != null);

            var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
            {
                var (compilation, targets) = source;
                var distinctMocks = new HashSet<string>();

                foreach (var target in targets)
                {
                    if (target!.Type == TargetType.Harness)
                    {
                        GenerateHarness(spc, target);
                    }
                    else if (target.Type == TargetType.Mock)
                    {
                        GenerateInterceptor(spc, target);

                        var symbolKey = target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        if (distinctMocks.Add(symbolKey)) 
                        {
                            GenerateMockClass(spc, target);
                        }
                    }
                }
            });
        }

        private static TargetInfo? GetTarget(GeneratorSyntaxContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            
            if (invocation.Expression is MemberAccessExpressionSyntax member && 
                member.Name.Identifier.Text == "Create") 
            {
                var expressionStr = member.Expression.ToString();
                TargetType? targetType = null;
                if (expressionStr == "Mock" || expressionStr.EndsWith(".Mock")) targetType = TargetType.Mock;
                else if (expressionStr == "Harness" || expressionStr.EndsWith(".Harness")) targetType = TargetType.Harness;

                if (targetType.HasValue && member.Name is GenericNameSyntax genericName)
                {
                    var typeArg = genericName.TypeArgumentList.Arguments.FirstOrDefault();
                    if (typeArg != null)
                    {
                        var symbol = context.SemanticModel.GetTypeInfo(typeArg).Type as INamedTypeSymbol;
                        if (symbol != null)
                            return new TargetInfo(symbol, member.Name.Identifier.GetLocation(), targetType.Value);
                    }
                }
            }
            return null;
        }

        private void GenerateMockClass(SourceProductionContext spc, TargetInfo target)
        {
            var symbol = target.Symbol;
            var stableHash = Math.Abs(symbol.ToDisplayString().GetHashCode()).ToString();
            var className = $"Skugga_{symbol.Name}_{stableHash}";
            var baseType = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var inheritance = $"{baseType}, Skugga.Core.IMockSetup";

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using Skugga.Core;

namespace Skugga.Generated
{{
    public class {className} : {inheritance}
    {{
        private readonly MockHandler _handler = new();
        public MockHandler Handler => _handler;
        
        // FIX: Use Fully Qualified Name for MockBehavior
        public {className}(Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose) 
        {{ 
            _handler.Behavior = behavior; 
        }}
");
            foreach (var method in GetAllMethods(symbol))
            {
                if (method.MethodKind != MethodKind.Ordinary) continue;
                if (symbol.TypeKind == TypeKind.Class && !method.IsVirtual && !method.IsAbstract && !method.IsOverride) continue;

                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var paramList = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}"));
                var argArray = method.Parameters.Length == 0 ? "Array.Empty<object?>()" : "new object?[] { " + string.Join(", ", method.Parameters.Select(p => p.Name)) + " }";

                if (method.ReturnsVoid)
                    sb.AppendLine($@"        public {modifier} void {method.Name}({paramList}) {{ _handler.Invoke(""{method.Name}"", {argArray}); }}");
                else
                {
                    var def = method.ReturnType.IsReferenceType ? "null!" : $"default({returnType})";
                    sb.AppendLine($@"        public {modifier} {returnType} {method.Name}({paramList}) {{ var r = _handler.Invoke(""{method.Name}"", {argArray}); return r != null ? ({returnType})r : {def}; }}");
                }
            }
            foreach (var prop in GetAllProperties(symbol))
            {
                if (symbol.TypeKind == TypeKind.Class && !prop.IsVirtual && !prop.IsAbstract && !prop.IsOverride) continue;
                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var type = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                sb.AppendLine($@"        public {modifier} {type} {prop.Name} {{ get {{ var r = _handler.Invoke(""get_{prop.Name}"", Array.Empty<object?>()); return r != null ? ({type})r : default({type})!; }} set {{ }} }}");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            spc.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateInterceptor(SourceProductionContext spc, TargetInfo target)
        {
            var stableHash = Math.Abs(target.Symbol.ToDisplayString().GetHashCode()).ToString();
            var targetClassName = $"Skugga_{target.Symbol.Name}_{stableHash}";
            var interceptorName = $"Interceptor_{Guid.NewGuid().ToString("N")}";
            var filePath = target.Location.SourceTree?.FilePath; 
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;

            spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("SKDEBUG", "Debug", $"Intercepting {filePath}:{line}", "Debug", DiagnosticSeverity.Warning, true), target.Location));

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {{
        public InterceptsLocationAttribute(string filePath, int line, int character) {{ }}
    }}
}}

namespace Skugga.Generated
{{
    public static class {interceptorName}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        // FIX: Use Fully Qualified Name for MockBehavior
        public static {target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} Create(Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose) 
        {{
            return new Skugga.Generated.{targetClassName}(behavior);
        }}
    }}
}}");
            spc.AddSource($"{interceptorName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateHarness(SourceProductionContext spc, TargetInfo target)
        {
            var sutSymbol = target.Symbol;
            var harnessClassName = $"Harness_{sutSymbol.Name}_{Guid.NewGuid().ToString("N").Substring(0, 8)}";
            var ctor = sutSymbol.Constructors.OrderByDescending(c => c.Parameters.Length).FirstOrDefault();
            var filePath = target.Location.SourceTree?.FilePath ?? "";
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;
            var interceptorName = $"Interceptor_{Guid.NewGuid().ToString("N")}";

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
using Skugga.Core;
using Skugga.Generated;
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute {{ public InterceptsLocationAttribute(string f, int l, int c) {{ }} }}
}}
namespace Skugga.Generated
{{
    public class {harnessClassName} : TestHarness<{sutSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>
    {{
        public {harnessClassName}()
        {{
");
            var args = new List<string>();
            if (ctor != null)
            {
                foreach (var param in ctor.Parameters)
                {
                    if (param.Type.TypeKind == TypeKind.Interface)
                    {
                        var stableHash = Math.Abs(param.Type.ToDisplayString().GetHashCode()).ToString();
                        var mockName = $"Skugga_{param.Type.Name}_{stableHash}";
                        sb.AppendLine($@"            var m_{param.Name} = new {mockName}(); _mocks[typeof({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})] = m_{param.Name};");
                        args.Add($"m_{param.Name}");
                    }
                    else args.Add("default!");
                }
            }
            sb.AppendLine($@"            SUT = new {sutSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}({string.Join(", ", args)});");
            sb.AppendLine("        } }");

            sb.AppendLine($@"
    public static class {interceptorName}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        public static TestHarness<{sutSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}> Create() => new {harnessClassName}();
    }}
}}"); 
            spc.AddSource($"{harnessClassName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static IEnumerable<IMethodSymbol> GetAllMethods(INamedTypeSymbol symbol) { return symbol.GetMembers().OfType<IMethodSymbol>().Concat(symbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IMethodSymbol>())); }
        private static IEnumerable<IPropertySymbol> GetAllProperties(INamedTypeSymbol symbol) { return symbol.GetMembers().OfType<IPropertySymbol>().Concat(symbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IPropertySymbol>())); }
        enum TargetType { Mock, Harness }
        class TargetInfo { public INamedTypeSymbol Symbol; public Location Location; public TargetType Type; public TargetInfo(INamedTypeSymbol s, Location l, TargetType t) { Symbol=s; Location=l; Type=t; } }
    }
}