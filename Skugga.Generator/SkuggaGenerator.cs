using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using System;
using System.Collections.Immutable;

namespace Skugga.Generator
{
    [Generator]
    public class SkuggaGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is InvocationExpressionSyntax,
                transform: (ctx, _) => GetMockTarget(ctx)
            ).Where(m => m != null);

            var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
            {
                var (compilation, targets) = source;
                var distinctInterfaces = new HashSet<string>();

                foreach (var target in targets)
                {
                    GenerateInterceptor(spc, target);

                    // Use fully qualified name for deduplication
                    var symbolKey = target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (distinctInterfaces.Add(symbolKey)) 
                    {
                        GenerateMockClass(spc, target);
                    }
                }
            });
        }

        private static MockTarget? GetMockTarget(GeneratorSyntaxContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            if (invocation.Expression is MemberAccessExpressionSyntax member && 
                member.Name.Identifier.Text == "Create" &&
                member.Expression.ToString().EndsWith("Mock")) 
            {
                if (member.Name is GenericNameSyntax genericName)
                {
                    var typeArg = genericName.TypeArgumentList.Arguments.FirstOrDefault();
                    if (typeArg != null)
                    {
                        var symbol = context.SemanticModel.GetTypeInfo(typeArg).Type as INamedTypeSymbol;
                        if (symbol != null && symbol.TypeKind == TypeKind.Interface)
                        {
                            // Correctly capture the 'Create' identifier location
                            return new MockTarget(symbol, member.Name.Identifier.GetLocation());
                        }
                    }
                }
            }
            return null;
        }

        private void GenerateMockClass(SourceProductionContext spc, MockTarget target)
        {
            var symbol = target.Symbol;
            var stableHash = Math.Abs(symbol.ToDisplayString().GetHashCode()).ToString();
            var className = $"Skugga_{symbol.Name}_{stableHash}";
            
            // USE FULLY QUALIFIED FORMAT to handle namespaces automatically (global::System...)
            var fullInterfaceName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using Skugga.Core;

// We put the generated class in the 'Skugga.Generated' namespace to avoid collisions with global types
namespace Skugga.Generated
{{
    public class {className} : {fullInterfaceName}, IMockSetup
    {{
        private readonly Dictionary<string, object?> _results = new();

        public void SetupMethod(string signature, object? value)
        {{
            _results[signature] = value;
        }}
");
            var allMethods = GetAllMethods(symbol);

            foreach (var method in allMethods)
            {
                var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var methodName = method.Name;
                var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}"));
                var signatureKey = method.Name; 

                if (method.ReturnsVoid)
                {
                     sb.AppendLine($@"        public void {methodName}({parameters}) {{ }}");
                }
                else
                {
                    var defaultValue = method.ReturnType.IsReferenceType ? "null" : $"default({returnType})";
                    sb.AppendLine($@"
        public {returnType} {methodName}({parameters}) 
        {{
            if (_results.TryGetValue(""{signatureKey}"", out var val)) return ({returnType})val!;
            return {defaultValue};
        }}");
                }
            }
            sb.AppendLine("    }");
            sb.AppendLine("}");
            spc.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateInterceptor(SourceProductionContext spc, MockTarget target)
        {
            var stableHash = Math.Abs(target.Symbol.ToDisplayString().GetHashCode()).ToString();
            var targetClassName = $"Skugga_{target.Symbol.Name}_{stableHash}";
            var uniqueLocationHash = Math.Abs(target.Location.GetHashCode()).ToString() + "_" + Guid.NewGuid().ToString().Substring(0, 4);

            var lineSpan = target.Location.GetLineSpan();
            var filePath = target.Location.SourceTree?.FilePath.Replace("\\", "\\\\");
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {{
        public InterceptsLocationAttribute(string filePath, int line, int character) {{ }}
    }}
}}

namespace Skugga.Generated
{{
    public static class Interceptor_{uniqueLocationHash}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        public static {target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} InterceptCreate()
        {{
            // We instantiated the class inside Skugga.Generated, so we can refer to it directly
            return new Skugga.Generated.{targetClassName}();
        }}
    }}
}}");
            spc.AddSource($"Interceptor_{uniqueLocationHash}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static IEnumerable<IMethodSymbol> GetAllMethods(INamedTypeSymbol symbol)
        {
            var methods = symbol.GetMembers().OfType<IMethodSymbol>().ToList();
            foreach (var iface in symbol.AllInterfaces)
            {
                methods.AddRange(iface.GetMembers().OfType<IMethodSymbol>());
            }
            return methods;
        }
    }

    public class MockTarget
    {
        public INamedTypeSymbol Symbol { get; }
        public Location Location { get; }
        public MockTarget(INamedTypeSymbol symbol, Location location) 
        { 
            Symbol = symbol; 
            Location = location; 
        }
    }
}
