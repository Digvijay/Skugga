#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using System;
using System.Collections.Immutable;

namespace Skugga.Generator
{
    [Generator]
    public class SkuggaGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is InvocationExpressionSyntax,
                transform: (ctx, _) => GetMockTarget(ctx)
            ).Where(m => m != null);

            var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
            {
                var (compilation, targets) = source;
                var distinctInterfaces = new HashSet<string>();

                foreach (var target in targets)
                {
                    GenerateInterceptor(spc, target!);

                    var symbolKey = target!.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (distinctInterfaces.Add(symbolKey)) 
                    {
                        GenerateMockClass(spc, target!);
                    }
                }
            });
        }

        private static MockTarget? GetMockTarget(GeneratorSyntaxContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            if (invocation.Expression is MemberAccessExpressionSyntax member && 
                member.Name.Identifier.Text == "Create" &&
                member.Expression.ToString().EndsWith("Mock")) 
            {
                if (member.Name is GenericNameSyntax genericName)
                {
                    var typeArg = genericName.TypeArgumentList.Arguments.FirstOrDefault();
                    if (typeArg != null)
                    {
                        var symbol = context.SemanticModel.GetTypeInfo(typeArg).Type as INamedTypeSymbol;
                        if (symbol != null && symbol.TypeKind == TypeKind.Interface)
                        {
                            return new MockTarget(symbol, member.Name.Identifier.GetLocation());
                        }
                    }
                }
            }
            return null;
        }

        private void GenerateMockClass(SourceProductionContext spc, MockTarget target)
        {
            var symbol = target.Symbol;
            var stableHash = Math.Abs(symbol.ToDisplayString().GetHashCode()).ToString();
            var className = $"Skugga_{symbol.Name}_{stableHash}";
            var fullInterfaceName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using Skugga.Core;

namespace Skugga.Generated
{{
    public class {className} : {fullInterfaceName}, IMockSetup
    {{
        // Use the new MockHandler engine
        private readonly MockHandler _handler = new();

        public void AddSetup(string signature, object?[] args, object? value)
        {{
            _handler.AddSetup(signature, args, value);
        }}

        public object? Invoke(string signature, object?[] args)
        {{
            return _handler.Invoke(signature, args);
        }}
");
            // 1. Generate Methods
            var allMethods = GetAllMethods(symbol);
            foreach (var method in allMethods)
            {
                // Skip property accessors (get_X, set_X) as we handle them in properties loop
                if (method.MethodKind == MethodKind.PropertyGet || method.MethodKind == MethodKind.PropertySet) continue;

                var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var methodName = method.Name;
                var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}"));
                
                // Pass arguments array to handler
                var argArray = method.Parameters.Length == 0 
                    ? "Array.Empty<object?>()" 
                    : "new object?[] { " + string.Join(", ", method.Parameters.Select(p => p.Name)) + " }";

                if (method.ReturnsVoid)
                {
                     sb.AppendLine($@"        public void {methodName}({parameters}) {{ }}");
                }
                else
                {
                    var defaultValue = method.ReturnType.IsReferenceType ? "null!" : $"default({returnType})";
                    sb.AppendLine($@"
        public {returnType} {methodName}({parameters}) 
        {{
            var result = _handler.Invoke(""{methodName}"", {argArray});
            if (result != null) return ({returnType})result;
            return {defaultValue};
        }}");
                }
            }

            // 2. Generate Properties
            var allProps = GetAllProperties(symbol);
            foreach (var prop in allProps)
            {
                var type = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var name = prop.Name;
                
                sb.AppendLine($@"
        public {type} {name} 
        {{
            get 
            {{
                var result = _handler.Invoke(""get_{name}"", Array.Empty<object?>());
                if (result != null) return ({type})result;
                return default({type})!;
            }}
            set {{ }} // Setter does nothing for now
        }}");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            spc.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateInterceptor(SourceProductionContext spc, MockTarget target)
        {
            var stableHash = Math.Abs(target.Symbol.ToDisplayString().GetHashCode()).ToString();
            var targetClassName = $"Skugga_{target.Symbol.Name}_{stableHash}";
            var uniqueLocationHash = Math.Abs(target.Location.GetHashCode()).ToString() + "_" + Guid.NewGuid().ToString().Substring(0, 4);

            var lineSpan = target.Location.GetLineSpan();
            var filePath = target.Location.SourceTree?.FilePath.Replace("\\", "\\\\");
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;

            var sb = new StringBuilder();
            
            sb.AppendLine($@"// <auto-generated/>
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {{
        public InterceptsLocationAttribute(string filePath, int line, int character) {{ }}
    }}
}}

namespace Skugga.Generated
{{
    public static class Interceptor_{uniqueLocationHash}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        public static {target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} InterceptCreate()
        {{
            return new Skugga.Generated.{targetClassName}();
        }}
    }}
}}");
            spc.AddSource($"Interceptor_{uniqueLocationHash}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static IEnumerable<IMethodSymbol> GetAllMethods(INamedTypeSymbol symbol)
        {
            var methods = symbol.GetMembers().OfType<IMethodSymbol>().ToList();
            foreach (var iface in symbol.AllInterfaces)
            {
                methods.AddRange(iface.GetMembers().OfType<IMethodSymbol>());
            }
            return methods;
        }

        private static IEnumerable<IPropertySymbol> GetAllProperties(INamedTypeSymbol symbol)
        {
            var props = symbol.GetMembers().OfType<IPropertySymbol>().ToList();
            foreach (var iface in symbol.AllInterfaces)
            {
                props.AddRange(iface.GetMembers().OfType<IPropertySymbol>());
            }
            return props;
        }
    }

    public class MockTarget
    {
        public INamedTypeSymbol Symbol { get; }
        public Location Location { get; }
        public MockTarget(INamedTypeSymbol symbol, Location location) 
        { 
            Symbol = symbol; 
            Location = location; 
        }
    }
}