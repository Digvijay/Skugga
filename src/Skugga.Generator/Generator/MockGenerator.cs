#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using static Skugga.Generator.GeneratorHelpers;

namespace Skugga.Generator
{
    internal static class MockGenerator
    {
        public static (string BaseType, string MockClassName)? GenerateMockClass(SourceProductionContext spc, TargetInfo target, DiagnosticDescriptor sealedRule, DiagnosticDescriptor noVirtualRule)
        {
            var symbol = target.Symbol;
            if (symbol == null) return null;

            if (symbol.TypeKind == TypeKind.Class && symbol.IsSealed)
            {
                spc.ReportDiagnostic(Diagnostic.Create(sealedRule, target.Location, symbol.Name));
                return null;
            }

            if (symbol.TypeKind == TypeKind.Class)
            {
                var hasVirtualMembers = GetAllMethods(symbol).Any(m => m.IsVirtual || m.IsAbstract || m.IsOverride) ||
                                       GetAllProperties(symbol).Any(p => p.IsVirtual || p.IsAbstract || p.IsOverride);
                if (!hasVirtualMembers)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(noVirtualRule, target.Location, symbol.Name));
                }
            }

            var stableHash = GetStableHash(symbol.ToDisplayString());
            var className = $"Skugga_{symbol.Name}_{stableHash}";
            var baseType = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var baseList = new List<string> { baseType };
            foreach (var @interface in symbol.AllInterfaces)
            {
                baseList.Add(@interface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            }
            baseList.Add("Skugga.Core.IMockSetup");

            var inheritance = string.Join(", ", baseList.Distinct());

            var sb = new StringBuilder(2048);
            sb.AppendLine(AutoGeneratedComment);
            sb.AppendLine(NullableEnable);
            sb.AppendLine(SystemUsing);
            sb.AppendLine(SkuggaCoreUsing);
            sb.AppendLine();
            sb.AppendLine(SkuggaGeneratedNamespace);
            sb.AppendLine("{");
            sb.Append("    public class ");
            sb.Append(className);
            sb.Append(" : ");
            sb.AppendLine(inheritance);
            sb.AppendLine("    {");
            sb.AppendLine("        #pragma warning disable CS8618");
            sb.Append("        ");
            sb.AppendLine(MockHandlerField);
            sb.Append("        ");
            sb.AppendLine(HandlerProperty);
            sb.AppendLine();

            sb.AppendLine("        static ");
            sb.Append(className);
            sb.AppendLine("()");
            sb.AppendLine("        {");
            sb.Append("            Skugga.Core.MockDefaultValueProvider.RegisterMockFactory<");
            sb.Append(baseType);
            sb.Append(">(() => new ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.DefaultValue.Mock));");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.Append("        public ");
            sb.Append(baseType);
            sb.AppendLine(" Object => this;");
            sb.AppendLine();

            GenerateConstructors(sb, className, baseType);
            GenerateMethods(sb, symbol);
            GenerateProperties(sb, symbol);
            GenerateEvents(sb, symbol);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            spc.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            return (baseType, className);
        }

        private static void GenerateConstructors(StringBuilder sb, string className, string baseType)
        {
            sb.Append("        public ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose)");
            sb.AppendLine("        {");
            sb.AppendLine("            _handler.Behavior = behavior;");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.Append("        public ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.MockBehavior behavior, Skugga.Core.DefaultValue defaultValue)");
            sb.AppendLine("        {");
            sb.AppendLine("            _handler.Behavior = behavior;");
            sb.AppendLine("            _handler.DefaultValueStrategy = defaultValue;");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.Append("        public ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.DefaultValue defaultValue)");
            sb.AppendLine("        {");
            sb.AppendLine("            _handler.DefaultValueStrategy = defaultValue;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private static void GenerateMethods(StringBuilder sb, INamedTypeSymbol symbol)
        {
            var nameSignatureToReturnType = new Dictionary<string, string>();

            foreach (var method in GetAllMethods(symbol))
            {
                if (method.MethodKind != MethodKind.Ordinary || method.IsStatic) continue;
                if (method.ContainingType.SpecialType == SpecialType.System_Object) continue;

                // If we are mocking a class, we only want to override its virtual/abstract members.
                // We strongly avoid interface members unless the symbol IS an interface.
                if (symbol.TypeKind == TypeKind.Class)
                {
                    if (method.ContainingType.TypeKind == TypeKind.Interface) continue;
                    if (!method.IsVirtual && !method.IsAbstract && !method.IsOverride) continue;
                }

                if (method.IsSealed) continue;

                // Skip methods with ref struct parameters or return type (cannot be boxed)
                if (IsRefStructOrContainsRefStruct(method.ReturnType) || method.Parameters.Any(p => IsRefStructOrContainsRefStruct(p.Type))) continue;

                var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var nameSignature = $"{method.Name}({string.Join(", ", method.Parameters.Select(p => p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))})";

                bool needsExplicit = false;
                if (nameSignatureToReturnType.TryGetValue(nameSignature, out var existingReturnType))
                {
                    if (existingReturnType == returnType)
                    {
                        continue;
                    }

                    needsExplicit = true;
                }
                else
                {
                    nameSignatureToReturnType[nameSignature] = returnType;
                }

                bool isObsolete = method.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "System.ObsoleteAttribute");
                if (isObsolete) sb.AppendLine("        [System.Obsolete]");

                var accessibility = method.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Protected => "protected",
                    Accessibility.Internal => "internal",
                    Accessibility.ProtectedOrInternal => "protected internal",
                    Accessibility.ProtectedAndInternal => "private protected",
                    _ => "public"
                };

                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var modifierStr = string.IsNullOrEmpty(modifier) ? "" : modifier + " ";

                var typeParams = "";
                var typeConstraints = "";
                if (method.IsGenericMethod)
                {
                    var typeParamNames = string.Join(", ", method.TypeParameters.Select(tp => tp.Name));
                    typeParams = $"<{typeParamNames}>";
                    var constraints = method.TypeParameters
                        .Where(tp => tp.HasReferenceTypeConstraint || tp.HasValueTypeConstraint || tp.HasConstructorConstraint || tp.ConstraintTypes.Length > 0)
                        .Select(tp =>
                        {
                            var list = new List<string>();
                            if (tp.HasReferenceTypeConstraint) list.Add("class");
                            if (tp.HasValueTypeConstraint) list.Add("struct");
                            if (tp.HasConstructorConstraint) list.Add("new()");
                            list.AddRange(tp.ConstraintTypes.Select(ct => ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                            return $"where {tp.Name} : {string.Join(", ", list)}";
                        }).ToList();
                    if (constraints.Any()) typeConstraints = " " + string.Join(" ", constraints);
                }

                // returnType is already defined above
                var paramList = string.Join(", ", method.Parameters.Select(p =>
                {
                    var refKind = p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.In ? "in " : "";
                    return $"{refKind}{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))} {p.Name}";
                }));

                var argArray = method.Parameters.Length == 0 ? ArrayEmpty : "new object?[] { " + string.Join(", ", method.Parameters.Select(p => p.Name)) + " }";

                sb.AppendLine();
                sb.Append("        ");
                if (needsExplicit)
                {
                    sb.Append(returnType);
                    sb.Append(' ');
                    sb.Append(method.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    sb.Append('.');
                }
                else
                {
                    sb.Append(accessibility);
                    sb.Append(' ');
                    sb.Append(modifierStr);
                    sb.Append(returnType);
                    sb.Append(' ');
                }

                sb.Append(method.Name);
                sb.Append(typeParams);
                sb.Append('(');
                sb.Append(paramList);
                sb.Append(')');
                sb.AppendLine(typeConstraints);
                sb.AppendLine("        {");

                // Initialize out parameters to default values to satisfy compiler
                foreach (var param in method.Parameters.Where(p => p.RefKind == RefKind.Out))
                {
                    sb.Append("            ");
                    sb.Append(param.Name);
                    sb.AppendLine(" = default!;");
                }

                // Check if method has out/ref parameters that need special handling
                var hasOutOrRefParams = method.Parameters.Any(p => p.RefKind == RefKind.Out || p.RefKind == RefKind.Ref);
                bool canCallBase = symbol.TypeKind == TypeKind.Class && !method.IsAbstract;

                sb.Append("            var __cbArgs = ");
                sb.Append(argArray);
                sb.AppendLine(";");
                sb.Append("            var __result = _handler.Invoke(\"");
                sb.Append(method.Name);
                sb.Append("\", __cbArgs, ");
                sb.Append(method.ReturnsVoid ? "null" : GetDefaultValueForType(method.ReturnType, returnType));
                sb.Append(", ");
                sb.Append(canCallBase.ToString().ToLower());
                sb.AppendLine(");");

                if (canCallBase)
                {
                    sb.AppendLine("            if (object.ReferenceEquals(__result, global::Skugga.Core.MockSetup.CallBaseMarker))");
                    sb.AppendLine("            {");
                    sb.Append("                ");
                    if (!method.ReturnsVoid) sb.Append("return ");
                    sb.Append("base.");
                    sb.Append(method.Name);
                    if (method.IsGenericMethod)
                    {
                        sb.Append("<");
                        sb.Append(string.Join(", ", method.TypeParameters.Select(tp => tp.Name)));
                        sb.Append(">");
                    }
                    sb.Append("(");
                    sb.Append(string.Join(", ", method.Parameters.Select(p =>
                    {
                        var refKind = p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.Ref ? "ref " : "";
                        return $"{refKind}{p.Name}";
                    })));
                    sb.AppendLine(");");
                    if (method.ReturnsVoid) sb.AppendLine("                return;");
                    sb.AppendLine("            }");
                }

                if (hasOutOrRefParams)
                {
                    sb.AppendLine("            if (__result is global::Skugga.Core.MockSetup __setup)");
                    sb.AppendLine("            {");

                    // Precedence: RefOutCallback > ValueFactories > Static Values
                    sb.AppendLine("                if (__setup.RefOutCallback != null)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    __setup.RefOutCallback.DynamicInvoke(__cbArgs);");
                    sb.AppendLine("                }");

                    for (int i = 0; i < method.Parameters.Length; i++)
                    {
                        var param = method.Parameters[i];
                        if (param.RefKind == RefKind.Out || param.RefKind == RefKind.Ref)
                        {
                            var paramType = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var dictName = param.RefKind == RefKind.Out ? "OutValues" : "RefValues";
                            var factoryName = param.RefKind == RefKind.Out ? "OutValueFactories" : "RefValueFactories";

                            sb.AppendLine($"                if (__setup.RefOutCallback != null)");
                            sb.AppendLine($"                    {param.Name} = ({paramType})__cbArgs[{i}]!;");
                            sb.AppendLine("                else");
                            sb.AppendLine("                {");
                            sb.AppendLine($"                    if (__setup.{factoryName}?.ContainsKey({i}) == true)");
                            sb.AppendLine($"                        {param.Name} = ({paramType})__setup.{factoryName}[{i}](__cbArgs)!;");
                            sb.AppendLine($"                    else if (__setup.{dictName}?.ContainsKey({i}) == true)");
                            sb.AppendLine($"                        {param.Name} = ({paramType})__setup.{dictName}[{i}]!;");
                            sb.AppendLine("                }");
                        }
                    }

                    if (!method.ReturnsVoid)
                    {
                        sb.Append("                return (__setup.ValueFactory != null ? __setup.ValueFactory(__cbArgs) : __setup.Value) is ");
                        sb.Append(returnType);
                        sb.AppendLine(" __value ? __value : default!;");
                    }
                    sb.AppendLine("            }");
                }

                if (!method.ReturnsVoid)
                {
                    sb.Append("            return (");
                    sb.Append(returnType);
                    sb.AppendLine(")__result!;");
                }
                sb.AppendLine("        }");
            }
        }

        private static void GenerateProperties(StringBuilder sb, INamedTypeSymbol symbol)
        {
            var nameToType = new Dictionary<string, string>();
            foreach (var prop in GetAllProperties(symbol))
            {
                if (prop.IsStatic) continue;
                if (prop.ContainingType.SpecialType == SpecialType.System_Object) continue;

                // If we are mocking a class, we only want to override its virtual/abstract members.
                if (symbol.TypeKind == TypeKind.Class)
                {
                    if (prop.ContainingType.TypeKind == TypeKind.Interface) continue;
                    if (!prop.IsVirtual && !prop.IsAbstract && !prop.IsOverride) continue;
                }

                // Skip properties with ref struct types (cannot be boxed)
                if (IsRefStructOrContainsRefStruct(prop.Type) || prop.Parameters.Any(p => IsRefStructOrContainsRefStruct(p.Type))) continue;

                var type = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var propKey = prop.IsIndexer
                    ? $"this[{string.Join(",", prop.Parameters.Select(p => p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))}]"
                    : prop.Name;

                if (nameToType.TryGetValue(propKey, out var existingType))
                {
                    if (existingType == type)
                    {
                        // True duplicate. Skip.
                        continue;
                    }

                    // Conflict. Explicit implementation.
                    if (symbol.TypeKind == TypeKind.Interface || symbol.TypeKind == TypeKind.Class)
                    {
                        GenerateExplicitProperty(sb, symbol, prop);
                    }
                    continue;
                }
                else
                {
                    nameToType[propKey] = type;
                }

                bool isObsolete = prop.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "System.ObsoleteAttribute");
                if (isObsolete) sb.AppendLine("        [System.Obsolete]");

                var accessibility = prop.DeclaredAccessibility.ToString().ToLower();
                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var modifierStr = string.IsNullOrEmpty(modifier) ? "" : modifier + " ";

                var propName = prop.IsIndexer ? "this" : prop.Name;
                var paramList = prop.IsIndexer
                    ? "[" + string.Join(", ", prop.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))} {p.Name}")) + "]"
                    : "";
                var argArray = prop.Parameters.Length == 0 ? ArrayEmpty : "new object?[] { " + string.Join(", ", prop.Parameters.Select(p => p.Name)) + " }";

                sb.AppendLine();
                sb.Append("        ");
                sb.Append(accessibility);
                sb.Append(' ');
                sb.Append(modifierStr);
                sb.Append(type);
                sb.Append(' ');
                sb.Append(propName);
                sb.Append(paramList);
                sb.AppendLine();
                sb.AppendLine("        {");

                bool canCallBase = symbol.TypeKind == TypeKind.Class && !prop.IsAbstract;

                if (prop.GetMethod != null)
                {
                    sb.Append("            get { var __result = _handler.Invoke(\"get_");
                    sb.Append(prop.Name);
                    sb.Append("\", ");
                    sb.Append(argArray);
                    sb.Append(", ");
                    sb.Append(GetDefaultValueForType(prop.Type, type));
                    sb.Append(", ");
                    sb.Append(canCallBase.ToString().ToLower());
                    sb.AppendLine(");");
                    if (canCallBase)
                    {
                        sb.AppendLine("                if (object.ReferenceEquals(__result, global::Skugga.Core.MockSetup.CallBaseMarker))");
                        sb.Append("                    return base.");
                        sb.Append(propName);
                        if (prop.IsIndexer) sb.Append($"[{string.Join(", ", prop.Parameters.Select(p => p.Name))}]");
                        sb.AppendLine(";");
                    }
                    sb.Append("                return (");
                    sb.Append(type);
                    sb.AppendLine(")__result!; }");
                }
                if (prop.SetMethod != null)
                {
                    var setArgArray = prop.Parameters.Length == 0
                        ? "new object?[] { value }"
                        : "new object?[] { " + string.Join(", ", prop.Parameters.Select(p => p.Name)) + ", value }";

                    sb.Append("            set { var __result = _handler.Invoke(\"set_");
                    sb.Append(prop.Name);
                    sb.Append("\", ");
                    sb.Append(setArgArray);
                    sb.Append(", null, ");
                    sb.Append(canCallBase.ToString().ToLower());
                    sb.AppendLine(");");
                    if (canCallBase)
                    {
                        sb.AppendLine("                if (object.ReferenceEquals(__result, global::Skugga.Core.MockSetup.CallBaseMarker))");
                        sb.Append("                { base.");
                        sb.Append(propName);
                        if (prop.IsIndexer) sb.Append($"[{string.Join(", ", prop.Parameters.Select(p => p.Name))}]");
                        sb.AppendLine(" = value; return; }");
                    }
                    sb.AppendLine("            }");
                }
                sb.AppendLine("        }");
            }
        }

        private static void GenerateExplicitProperty(StringBuilder sb, INamedTypeSymbol symbol, IPropertySymbol prop)
        {
            var interfaceType = prop.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var type = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));

            var paramList = prop.IsIndexer
                ? "[" + string.Join(", ", prop.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))} {p.Name}")) + "]"
                : "";
            var argArray = prop.Parameters.Length == 0 ? ArrayEmpty : "new object?[] { " + string.Join(", ", prop.Parameters.Select(p => p.Name)) + " }";

            sb.AppendLine();
            sb.Append("        ");
            sb.Append(type);
            sb.Append(' ');
            sb.Append(interfaceType);
            sb.Append('.');
            sb.Append(prop.IsIndexer ? "this" : prop.Name);
            sb.Append(paramList);
            sb.AppendLine();
            sb.AppendLine("        {");

            if (prop.GetMethod != null)
            {
                sb.Append("            get { var __result = _handler.Invoke(\"get_");
                sb.Append(prop.Name);
                sb.Append("\", ");
                sb.Append(argArray);
                sb.Append(", ");
                sb.Append(GetDefaultValueForType(prop.Type, type));
                sb.AppendLine(", false);");
                sb.Append("                return (");
                sb.Append(type);
                sb.AppendLine(")__result!; }");
            }
            if (prop.SetMethod != null)
            {
                var setArgArray = prop.Parameters.Length == 0
                    ? "new object?[] { value }"
                    : "new object?[] { " + string.Join(", ", prop.Parameters.Select(p => p.Name)) + ", value }";

                sb.Append("            set { _handler.Invoke(\"set_");
                sb.Append(prop.Name);
                sb.Append("\", ");
                sb.Append(setArgArray);
                sb.AppendLine(", null, false); }");
            }
            sb.AppendLine("        }");
        }

        private static void GenerateEvents(StringBuilder sb, INamedTypeSymbol symbol)
        {
            foreach (var @event in GetAllEvents(symbol))
            {
                if (symbol.TypeKind == TypeKind.Class && !@event.IsVirtual && !@event.IsAbstract && !@event.IsOverride) continue;

                var accessibility = @event.DeclaredAccessibility.ToString().ToLower();
                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var modifierStr = string.IsNullOrEmpty(modifier) ? "" : modifier + " ";
                var type = @event.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));

                sb.AppendLine();
                sb.Append("        ");
                sb.Append(accessibility);
                sb.Append(' ');
                sb.Append(modifierStr);
                sb.Append("event ");
                sb.Append(type);
                sb.Append(' ');
                sb.Append(@event.Name);
                sb.AppendLine();
                sb.AppendLine("        {");
                sb.AppendLine($"            add => Handler.Invoke(\"add_{@event.Name}\", new object?[] {{ value }});");
                sb.AppendLine($"            remove => Handler.Invoke(\"remove_{@event.Name}\", new object?[] {{ value }});");
                sb.AppendLine("        }");
            }
            sb.AppendLine("        #pragma warning restore CS8618");
        }
    }
}
