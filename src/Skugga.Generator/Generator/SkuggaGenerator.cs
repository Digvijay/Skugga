#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.Operations;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using System;
using System.Collections.Immutable;

namespace Skugga.Generator
{
    [Generator]
    public class SkuggaGenerator : IIncrementalGenerator
    {
        // String constants to reduce allocations
        private const string AutoGeneratedComment = "// <auto-generated/>";
        private const string NullableEnable = "#nullable enable";
        private const string SystemUsing = "using System;";
        private const string SkuggaCoreUsing = "using Skugga.Core;";
        private const string SkuggaGeneratedNamespace = "namespace Skugga.Generated";
        private const string MockHandlerField = "private readonly MockHandler _handler = new();";
        private const string HandlerProperty = "public MockHandler Handler => _handler;";
        private const string ArrayEmpty = "Array.Empty<object?>()";
        
        private static readonly DiagnosticDescriptor SealedClassRule = new(
            id: "SKUGGA001",
            title: "Cannot mock sealed class",
            messageFormat: "Cannot mock sealed class '{0}'. Sealed classes cannot be mocked.",
            category: "Skugga",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true,
            description: "Skugga cannot generate mocks for sealed classes.");

        private static readonly DiagnosticDescriptor NoVirtualMembersRule = new(
            id: "SKUGGA002",
            title: "Class has no virtual members",
            messageFormat: "Class '{0}' has no virtual members to mock. Consider mocking an interface instead or make members virtual.",
            category: "Skugga",
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true,
            description: "Classes must have virtual members to be mocked effectively.");
            
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is InvocationExpressionSyntax,
                transform: (ctx, _) => GetTarget(ctx)
            ).Where(m => m != null);

            var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
            {
                var (compilation, targets) = source;
                var distinctMocks = new HashSet<string>();

                foreach (var target in targets)
                {
                    if (target!.Type == TargetType.Harness)
                    {
                        GenerateHarness(spc, target);
                    }
                    else if (target.Type == TargetType.Mock)
                    {
                        GenerateInterceptor(spc, target);

                        var symbolKey = target.Symbol!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        if (distinctMocks.Add(symbolKey)) 
                        {
                            GenerateMockClass(spc, target);
                        }
                    }
                    else if (target.Type == TargetType.AutoScribe)
                    {
                        GenerateAutoScribeInterceptor(spc, target);
                        
                        var symbolKey = target.Symbol!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        if (distinctMocks.Add(symbolKey + "_AutoScribe"))
                        {
                            GenerateRecordingProxy(spc, target);
                        }
                    }
                    else if (target.Type == TargetType.Setup || target.Type == TargetType.Verify)
                    {
                        // Generate interceptor for Setup/Verify calls
                        if (target.MethodName != null && target.Arguments != null)
                        {
                            GenerateSetupVerifyInterceptor(spc, target);
                        }
                    }
                }
            });
        }

        private static string? TryExtractVariableArgument(GeneratorSyntaxContext context, ExpressionSyntax expression)
        {
            // Try to extract value from variables, fields, properties, or simple expressions
            // For compile-time generation, we inline the expression directly into the generated code
            
            switch (expression)
            {
                case IdentifierNameSyntax identifier:
                    // Variable reference: myVariable
                    // Inline it directly - the variable value will be captured at test runtime
                    return identifier.Identifier.Text;
                
                case MemberAccessExpressionSyntax memberAccess:
                    // Property/field access: obj.Property or this.field
                    // Check if we can evaluate it at compile-time
                    var operation = context.SemanticModel.GetOperation(memberAccess);
                    if (operation is IFieldReferenceOperation fieldRef && fieldRef.Field.IsConst)
                    {
                        // It's a const field - we can evaluate it
                        var constantValue = context.SemanticModel.GetConstantValue(memberAccess);
                        if (constantValue.HasValue)
                        {
                            return FormatConstantValue(constantValue.Value);
                        }
                    }
                    // For non-const members, inline the expression
                    return memberAccess.ToString();
                
                case BinaryExpressionSyntax binaryExpr:
                    // Calculations: x + 1, count * 2, etc.
                    // Try to evaluate at compile-time first
                    var binaryConstant = context.SemanticModel.GetConstantValue(binaryExpr);
                    if (binaryConstant.HasValue)
                    {
                        return FormatConstantValue(binaryConstant.Value);
                    }
                    // If not constant, inline the expression
                    return $"({binaryExpr})";
                
                case InvocationExpressionSyntax invocation:
                    // Method calls: GetValue(), obj.Method(), etc.
                    // We can't evaluate these at compile-time, inline them
                    return invocation.ToString();
                
                case ElementAccessExpressionSyntax elementAccess:
                    // Array/indexer access: array[0], dict[key]
                    return elementAccess.ToString();
                
                case CastExpressionSyntax castExpr:
                    // Cast: (int)value
                    var innerExtracted = TryExtractVariableArgument(context, castExpr.Expression);
                    if (innerExtracted != null)
                    {
                        return $"({castExpr.Type}){innerExtracted}";
                    }
                    return castExpr.ToString();
                
                case ParenthesizedExpressionSyntax parenthesized:
                    // Parenthesized expression: (expr)
                    return TryExtractVariableArgument(context, parenthesized.Expression);
                
                case ConditionalExpressionSyntax conditional:
                    // Ternary: condition ? a : b
                    return conditional.ToString();
                
                case PrefixUnaryExpressionSyntax or PostfixUnaryExpressionSyntax:
                    // Unary operators: !value, -number, ++i, etc.
                    return expression.ToString();
                
                default:
                    // Unknown expression type - return null to skip interception
                    return null;
            }
        }

        private static (string? methodName, List<string> arguments, bool isProperty)? ParseLambdaExpression(
            GeneratorSyntaxContext context, ExpressionSyntax lambdaExpr)
        {
            // Parse lambda: x => x.Method(arg1, arg2) or x => x.Property
            if (lambdaExpr is not LambdaExpressionSyntax lambda)
                return null;

            var body = lambda.Body;
            
            // Handle method call: x => x.Method(args)
            if (body is InvocationExpressionSyntax invocation &&
                invocation.Expression is MemberAccessExpressionSyntax methodAccess)
            {
                var methodName = methodAccess.Name.Identifier.Text;
                var arguments = new List<string>();
                
                foreach (var arg in invocation.ArgumentList.Arguments)
                {
                    // Use semantic model to evaluate constant expressions
                    var constantValue = context.SemanticModel.GetConstantValue(arg.Expression);
                    if (constantValue.HasValue)
                    {
                        // Format constant value as C# literal
                        arguments.Add(FormatConstantValue(constantValue.Value));
                    }
                    else
                    {
                        // Check if it's It.IsAny<T>() or other It.* matchers
                        var argText = arg.Expression.ToString();
                        if (argText.Contains("It.IsAny"))
                        {
                            // Get the type argument
                            var typeInfo = context.SemanticModel.GetTypeInfo(arg.Expression);
                            if (typeInfo.Type != null)
                            {
                                arguments.Add($"new ArgumentMatcher(typeof({typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}), _ => true, \"It.IsAny<{typeInfo.Type.Name}>()\")");
                            }
                        }
                        else if (argText.Contains("It.Is") || argText.Contains("It.IsIn") || 
                                 argText.Contains("It.IsNotIn") || argText.Contains("It.IsNull") ||
                                 argText.Contains("It.IsNotNull") || argText.Contains("It.IsRegex") ||
                                 argText.Contains("Match.Create"))
                        {
                            // Let runtime handle complex It.* matchers and Match.Create
                            return null;
                        }
                        else
                        {
                            // Non-constant argument - could be variable, field, property, or calculation
                            // Try to extract the value by capturing the expression as code
                            var extracted = TryExtractVariableArgument(context, arg.Expression);
                            if (extracted != null)
                            {
                                arguments.Add(extracted);
                            }
                            else
                            {
                                // Can't extract - skip interception and let runtime handle it
                                return null;
                            }
                        }
                    }
                }
                
                return (methodName, arguments, false);
            }
            
            // Handle property access: x => x.Property
            if (body is MemberAccessExpressionSyntax propertyAccess)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(propertyAccess).Symbol;
                if (symbol is IPropertySymbol property)
                {
                    return ("get_" + property.Name, new List<string>(), true);
                }
            }
            
            return null;
        }

        private static string FormatConstantValue(object? value)
        {
            if (value == null) return "null";
            if (value is string s) return $"\"{s.Replace("\"", "\\\"")}\"";
            if (value is bool b) return b ? "true" : "false";
            if (value is char c) return $"'{c}'";
            return value.ToString() ?? "null";
        }

        private static TargetInfo? GetTarget(GeneratorSyntaxContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            
            if (invocation.Expression is MemberAccessExpressionSyntax member)
            {
                var methodName = member.Name.Identifier.Text;
                
                // Handle Mock.Create<T>(), Harness.Create<T>(), and AutoScribe.Capture<T>()
                // Note: Mock.Of<T>() is NOT intercepted - it calls Mock.Create internally which IS intercepted
                if (methodName == "Create" || methodName == "Capture")
                {
                    var expressionStr = member.Expression.ToString();
                    TargetType? targetType = null;
                    if (expressionStr == "Mock" || expressionStr.EndsWith(".Mock")) targetType = TargetType.Mock;
                    else if (expressionStr == "Harness" || expressionStr.EndsWith(".Harness")) targetType = TargetType.Harness;
                    else if ((expressionStr == "AutoScribe" || expressionStr.EndsWith(".AutoScribe")) && methodName == "Capture") 
                        targetType = TargetType.AutoScribe;

                    if (targetType.HasValue && member.Name is GenericNameSyntax genericName)
                    {
                        var typeArg = genericName.TypeArgumentList.Arguments.FirstOrDefault();
                        if (typeArg != null)
                        {
                            var symbol = context.SemanticModel.GetTypeInfo(typeArg).Type as INamedTypeSymbol;
                            if (symbol != null)
                                return new TargetInfo(symbol, member.Name.Identifier.GetLocation(), targetType.Value, null, invocation);
                        }
                    }
                }
                // Handle mock.Setup() and mock.Verify()
                else if (methodName == "Setup" || methodName == "Verify")
                {
                    // Get the type of the mock object (left side of the call)
                    var mockType = context.SemanticModel.GetTypeInfo(member.Expression).Type;
                    
                    // Extract the lambda expression argument
                    if (invocation.ArgumentList.Arguments.Count > 0)
                    {
                        var lambdaArg = invocation.ArgumentList.Arguments[0].Expression;
                        var targetType = methodName == "Setup" ? TargetType.Setup : TargetType.Verify;
                        
                        // Parse the lambda expression to extract method name and arguments
                        var parsed = ParseLambdaExpression(context, lambdaArg);
                        if (parsed.HasValue)
                        {
                            return new TargetInfo(mockType as INamedTypeSymbol, member.Name.Identifier.GetLocation(), 
                                targetType, lambdaArg, invocation, parsed.Value.methodName, 
                                parsed.Value.arguments, parsed.Value.isProperty);
                        }
                        else
                        {
                            // Can't parse - likely uses variables, skip interception
                            return null;
                        }
                    }
                }
            }
            return null;
        }

        private void GenerateMockClass(SourceProductionContext spc, TargetInfo target)
        {
            var symbol = target.Symbol;            if (symbol == null) return;            if (symbol == null) return;
            
            // Check for sealed class
            if (symbol.TypeKind == TypeKind.Class && symbol.IsSealed)
            {
                var diagnostic = Diagnostic.Create(SealedClassRule, target.Location, symbol.Name);
                spc.ReportDiagnostic(diagnostic);
                return; // Cannot generate mock for sealed class
            }
            
            // Check for class with no virtual members
            if (symbol.TypeKind == TypeKind.Class)
            {
                var hasVirtualMembers = GetAllMethods(symbol).Any(m => m.IsVirtual || m.IsAbstract || m.IsOverride) ||
                                       GetAllProperties(symbol).Any(p => p.IsVirtual || p.IsAbstract || p.IsOverride);
                if (!hasVirtualMembers)
                {
                    var diagnostic = Diagnostic.Create(NoVirtualMembersRule, target.Location, symbol.Name);
                    spc.ReportDiagnostic(diagnostic);
                    // Continue generating but user is warned
                }
            }
            
            var stableHash = GetStableHash(symbol.ToDisplayString());
            var className = $"Skugga_{symbol.Name}_{stableHash}";
            var baseType = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var inheritance = $"{baseType}, Skugga.Core.IMockSetup";

            var sb = new StringBuilder(2048); // Pre-allocate reasonable size
            sb.AppendLine(AutoGeneratedComment);
            sb.AppendLine(NullableEnable);
            sb.AppendLine(SystemUsing);
            sb.AppendLine(SkuggaCoreUsing);
            sb.AppendLine();
            sb.AppendLine(SkuggaGeneratedNamespace);
            sb.AppendLine("{");
            sb.Append("    /// <summary>\n    /// Mock implementation for <see cref=\"");
            sb.Append(baseType);
            sb.AppendLine("\"/>.");
            sb.AppendLine("    /// Generated by Skugga source generator.");
            sb.AppendLine("    /// </summary>");
            sb.Append("    public class ");
            sb.Append(className);
            sb.Append(" : ");
            sb.AppendLine(inheritance);
            sb.AppendLine("    {");
            sb.Append("        ");
            sb.AppendLine(MockHandlerField);
            sb.Append("        ");
            sb.AppendLine(HandlerProperty);
            sb.AppendLine();
            
            // Add static constructor to register mock factory for recursive mocking
            sb.AppendLine("        static ");
            sb.Append(className);
            sb.AppendLine("()");
            sb.AppendLine("        {");
            sb.Append("            Skugga.Core.MockDefaultValueProvider.RegisterMockFactory<");
            sb.Append(baseType);
            sb.Append(">(() => new ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.DefaultValue.Mock));");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets the mock object itself. This property exists for compatibility with other mocking frameworks.");
            sb.AppendLine("        /// In Skugga, the mock instance IS the interface - there's no separate .Object property needed.");
            sb.AppendLine("        /// </summary>");
            sb.Append("        public ");
            sb.Append(baseType);
            sb.AppendLine(" Object => this;");
            sb.AppendLine("        ");
            sb.Append("        /// <summary>\n        /// Initializes a new instance of the <see cref=\"");
            sb.Append(className);
            sb.AppendLine("\"/> class.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"behavior\">The mock behavior (Loose or Strict).</param>");
            sb.Append("        public ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose)");
            sb.AppendLine("        {");
            sb.AppendLine("            _handler.Behavior = behavior;");
            sb.AppendLine("        }");
            sb.AppendLine("        ");
            sb.Append("        /// <summary>\n        /// Initializes a new instance with behavior and default value strategy.\n        /// </summary>");
            sb.AppendLine();
            sb.AppendLine("        /// <param name=\"behavior\">The mock behavior (Loose or Strict).</param>");
            sb.AppendLine("        /// <param name=\"defaultValue\">The default value strategy (Empty or Mock).</param>");
            sb.Append("        public ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.MockBehavior behavior, Skugga.Core.DefaultValue defaultValue)");
            sb.AppendLine("        {");
            sb.AppendLine("            _handler.Behavior = behavior;");
            sb.AppendLine("            _handler.DefaultValueStrategy = defaultValue;");
            sb.AppendLine("        }");
            sb.AppendLine("        ");
            sb.Append("        /// <summary>\n        /// Initializes a new instance with default value strategy.\n        /// </summary>");
            sb.AppendLine();
            sb.AppendLine("        /// <param name=\"defaultValue\">The default value strategy (Empty or Mock).</param>");
            sb.Append("        public ");
            sb.Append(className);
            sb.AppendLine("(Skugga.Core.DefaultValue defaultValue)");
            sb.AppendLine("        {");
            sb.AppendLine("            _handler.DefaultValueStrategy = defaultValue;");
            sb.AppendLine("        }");
            foreach (var method in GetAllMethods(symbol))
            {
                if (method.MethodKind != MethodKind.Ordinary) continue;
                if (symbol.TypeKind == TypeKind.Class && !method.IsVirtual && !method.IsAbstract && !method.IsOverride) continue;

                // Determine accessibility modifier
                var accessibility = method.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Protected => "protected",
                    Accessibility.Internal => "internal",
                    Accessibility.ProtectedOrInternal => "protected internal",
                    Accessibility.ProtectedAndInternal => "private protected",
                    _ => "public" // Default to public for interfaces
                };
                
                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var modifierStr = string.IsNullOrEmpty(modifier) ? "" : modifier + " ";
                
                // Handle generic methods - extract type parameters
                var typeParams = "";
                var typeConstraints = "";
                if (method.IsGenericMethod)
                {
                    var typeParamNames = string.Join(", ", method.TypeParameters.Select(tp => tp.Name));
                    typeParams = $"<{typeParamNames}>";
                    
                    // Add type constraints if any
                    var constraints = method.TypeParameters
                        .Where(tp => tp.HasReferenceTypeConstraint || tp.HasValueTypeConstraint || tp.HasConstructorConstraint || tp.ConstraintTypes.Length > 0)
                        .Select(tp =>
                        {
                            var constraintList = new List<string>();
                            if (tp.HasReferenceTypeConstraint) constraintList.Add("class");
                            if (tp.HasValueTypeConstraint) constraintList.Add("struct");
                            if (tp.HasConstructorConstraint) constraintList.Add("new()");
                            constraintList.AddRange(tp.ConstraintTypes.Select(ct => ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                            return $"where {tp.Name} : {string.Join(", ", constraintList)}";
                        }).ToList();
                    
                    if (constraints.Any())
                    {
                        typeConstraints = " " + string.Join(" ", constraints);
                    }
                }
                
                var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                
                // Build parameter list with out/ref modifiers
                var paramList = string.Join(", ", method.Parameters.Select(p =>
                {
                    var refKind = p.RefKind == RefKind.Out ? "out " :
                                  p.RefKind == RefKind.Ref ? "ref " :
                                  p.RefKind == RefKind.In ? "in " :
                                  "";
                    return $"{refKind}{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))} {p.Name}";
                }));
                
                var argArray = method.Parameters.Length == 0 ? ArrayEmpty : "new object?[] { " + string.Join(", ", method.Parameters.Select(p => p.Name)) + " }";
                
                // Check if method has out or ref parameters
                var hasOutOrRef = method.Parameters.Any(p => p.RefKind == RefKind.Out || p.RefKind == RefKind.Ref);

                sb.AppendLine(); // Add blank line before each method
                if (method.ReturnsVoid)
                {
                    sb.Append("        ");
                    sb.Append(accessibility);
                    sb.Append(' ');
                    sb.Append(modifierStr);
                    sb.Append("void ");
                    sb.Append(method.Name);
                    sb.Append(typeParams);
                    sb.Append('(');
                    sb.Append(paramList);
                    sb.Append(')');
                    sb.AppendLine(typeConstraints);
                    sb.AppendLine("        {");
                    
                    if (hasOutOrRef)
                    {
                        // Initialize out parameters with default values
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            var param = method.Parameters[i];
                            if (param.RefKind == RefKind.Out)
                            {
                                sb.Append("            ");
                                sb.Append(param.Name);
                                sb.Append(" = default(");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.AppendLine(")!;");
                            }
                        }
                        
                        sb.Append("            var setup = _handler.Invoke(\"");
                        sb.Append(method.Name);
                        sb.Append("\", ");
                        sb.Append(argArray);
                        sb.AppendLine(") as Skugga.Core.MockSetup;");
                        
                        // Apply out/ref values - check factories first, then static values
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            var param = method.Parameters[i];
                            if (param.RefKind == RefKind.Out)
                            {
                                // Try factory first
                                sb.Append("            if (setup?.OutValueFactories?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.OutValueFactories[");
                                sb.Append(i);
                                sb.Append("](");
                                sb.Append(argArray);
                                sb.AppendLine(")!;");
                                
                                // Fall back to static value
                                sb.Append("            else if (setup?.OutValues?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.OutValues[");
                                sb.Append(i);
                                sb.AppendLine("]!;");
                            }
                            else if (param.RefKind == RefKind.Ref)
                            {
                                // Try factory first
                                sb.Append("            if (setup?.RefValueFactories?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.RefValueFactories[");
                                sb.Append(i);
                                sb.Append("](");
                                sb.Append(argArray);
                                sb.AppendLine(")!;");
                                
                                // Fall back to static value
                                sb.Append("            else if (setup?.RefValues?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.RefValues[");
                                sb.Append(i);
                                sb.AppendLine("]!;");
                            }
                        }
                        
                        // Invoke RefOutCallback if present
                        sb.AppendLine("            if (setup?.RefOutCallback != null)");
                        sb.AppendLine("            {");
                        sb.Append("                var callbackArgs = new object?[] { ");
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            if (i > 0) sb.Append(", ");
                            sb.Append(method.Parameters[i].Name);
                        }
                        sb.AppendLine(" };");
                        sb.AppendLine("                setup.RefOutCallback.DynamicInvoke(callbackArgs);");
                        
                        // Copy back ref/out values
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            var param = method.Parameters[i];
                            if (param.RefKind == RefKind.Ref || param.RefKind == RefKind.Out)
                            {
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")callbackArgs[");
                                sb.Append(i);
                                sb.AppendLine("]!;");
                            }
                        }
                        sb.AppendLine("            }");
                    }
                    else
                    {
                        sb.Append("            var setup = _handler.Invoke(\"");
                        sb.Append(method.Name);
                        sb.Append("\", ");
                        sb.Append(argArray);
                        sb.AppendLine(");");
                    }
                    
                    sb.AppendLine("        }");
                }
                else
                {
                    // Special handling for Task types to avoid null reference exceptions
                    var def = GetDefaultValueForType(method.ReturnType, returnType);
                    
                    sb.Append("        ");
                    sb.Append(accessibility);
                    sb.Append(' ');
                    sb.Append(modifierStr);
                    sb.Append(returnType);
                    sb.Append(' ');
                    sb.Append(method.Name);
                    sb.Append(typeParams);
                    sb.Append('(');
                    sb.Append(paramList);
                    sb.Append(')');
                    sb.AppendLine(typeConstraints);
                    sb.AppendLine("        {");
                    
                    if (hasOutOrRef)
                    {
                        // Initialize out parameters with default values
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            var param = method.Parameters[i];
                            if (param.RefKind == RefKind.Out)
                            {
                                sb.Append("            ");
                                sb.Append(param.Name);
                                sb.Append(" = default(");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.AppendLine(")!;");
                            }
                        }
                        
                        sb.Append("            var setup = _handler.Invoke(\"");
                        sb.Append(method.Name);
                        sb.Append("\", ");
                        sb.Append(argArray);
                        sb.AppendLine(") as Skugga.Core.MockSetup;");
                        
                        // Apply out/ref values - check factories first, then static values
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            var param = method.Parameters[i];
                            if (param.RefKind == RefKind.Out)
                            {
                                // Try factory first
                                sb.Append("            if (setup?.OutValueFactories?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.OutValueFactories[");
                                sb.Append(i);
                                sb.Append("](");
                                sb.Append(argArray);
                                sb.AppendLine(")!;");
                                
                                // Fall back to static value
                                sb.Append("            else if (setup?.OutValues?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.OutValues[");
                                sb.Append(i);
                                sb.AppendLine("]!;");
                            }
                            else if (param.RefKind == RefKind.Ref)
                            {
                                // Try factory first
                                sb.Append("            if (setup?.RefValueFactories?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.RefValueFactories[");
                                sb.Append(i);
                                sb.Append("](");
                                sb.Append(argArray);
                                sb.AppendLine(")!;");
                                
                                // Fall back to static value
                                sb.Append("            else if (setup?.RefValues?.ContainsKey(");
                                sb.Append(i);
                                sb.AppendLine(") == true)");
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")setup.RefValues[");
                                sb.Append(i);
                                sb.AppendLine("]!;");
                            }
                        }
                        
                        // Invoke RefOutCallback if present (cast to generated delegate type)
                        sb.AppendLine("            if (setup?.RefOutCallback != null)");
                        sb.AppendLine("            {");
                        sb.Append("                var callbackArgs = new object?[] { ");
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            if (i > 0) sb.Append(", ");
                            sb.Append(method.Parameters[i].Name);
                        }
                        sb.AppendLine(" };");
                        sb.AppendLine("                setup.RefOutCallback.DynamicInvoke(callbackArgs);");
                        
                        // Copy back ref/out values
                        for (int i = 0; i < method.Parameters.Length; i++)
                        {
                            var param = method.Parameters[i];
                            if (param.RefKind == RefKind.Ref || param.RefKind == RefKind.Out)
                            {
                                sb.Append("                ");
                                sb.Append(param.Name);
                                sb.Append(" = (");
                                sb.Append(param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                                sb.Append(")callbackArgs[");
                                sb.Append(i);
                                sb.AppendLine("]!;");
                            }
                        }
                        sb.AppendLine("            }");
                        
                        sb.Append("            return setup?.Value != null ? (");
                        sb.Append(returnType);
                        sb.Append(")setup.Value : _handler.GetDefaultValueFor<");
                        sb.Append(returnType);
                        sb.AppendLine(">(this)!;");;;
                    }
                    else
                    {
                        sb.Append("            var r = _handler.Invoke(\"");
                        sb.Append(method.Name);
                        sb.Append("\", ");
                        sb.Append(argArray);
                        sb.AppendLine(");");
                        sb.Append("            return r != null ? (");
                        sb.Append(returnType);
                        sb.Append(")r : _handler.GetDefaultValueFor<");
                        sb.Append(returnType);
                        sb.AppendLine(">(this)!;");
                    }
                    
                    sb.AppendLine("        }");
                }
            }
            
            sb.AppendLine(); // Add blank line before properties section
            foreach (var prop in GetAllProperties(symbol))
            {
                if (symbol.TypeKind == TypeKind.Class && !prop.IsVirtual && !prop.IsAbstract && !prop.IsOverride) continue;
                
                // Determine accessibility modifier for property
                var accessibility = prop.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Protected => "protected",
                    Accessibility.Internal => "internal",
                    Accessibility.ProtectedOrInternal => "protected internal",
                    Accessibility.ProtectedAndInternal => "private protected",
                    _ => "public"
                };
                
                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var modifierStr = string.IsNullOrEmpty(modifier) ? "" : modifier + " ";
                var type = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                // Check which accessors the property actually has
                // Interface properties can be { get; }, { set; }, or { get; set; }
                bool hasGetter = prop.GetMethod != null;
                bool hasSetter = prop.SetMethod != null;
                
                sb.AppendLine(); // Add blank line before each property
                sb.Append("        ");
                sb.Append(accessibility);
                sb.Append(' ');
                sb.Append(modifierStr);
                sb.Append(type);
                sb.Append(' ');
                sb.AppendLine(prop.Name);
                sb.AppendLine("        {");
                
                // Only generate getter if the property has one
                if (hasGetter)
                {
                sb.AppendLine("            get");
                sb.AppendLine("            {");
                // Check for explicit Setup first (takes precedence over SetupProperty)
                sb.Append("                var r = _handler.Invoke(\"get_");
                sb.Append(prop.Name);
                sb.Append("\", ");
                sb.Append(ArrayEmpty);
                sb.AppendLine(");");
                sb.AppendLine("                if (r != null)");
                sb.AppendLine("                {");
                sb.Append("                    return (");
                sb.Append(type);
                sb.AppendLine(")r;");
                sb.AppendLine("                }");
                sb.AppendLine();
                // Fall back to property backing storage (SetupProperty)
                sb.Append("                if (_handler.HasPropertyStorage(\"");
                sb.Append(prop.Name);
                sb.AppendLine("\"))");
                sb.AppendLine("                {");
                sb.Append("                    var stored = _handler.GetPropertyValue(\"");
                sb.Append(prop.Name);
                sb.AppendLine("\");");
                sb.Append("                    return stored != null ? (");
                sb.Append(type);
                sb.Append(")stored : default(");
                sb.Append(type);
                sb.AppendLine(")!;");
                sb.AppendLine("                }");
                sb.AppendLine();
                // Final fallback - use default value provider
                sb.Append("                return _handler.GetDefaultValueFor<");
                sb.Append(type);
                sb.AppendLine(">(this)!;");
                sb.AppendLine("            }");
                }
                
                // Only generate setter if the property has one
                if (hasSetter)
                {
                // Property setter implementation
                // Track setter invocations for VerifySet support, and update backing storage if SetupProperty was called
                sb.AppendLine("            set");
                sb.AppendLine("            {");
                // Always track setter invocations as "set_PropertyName" with the value as argument
                // This enables VerifySet functionality
                sb.Append("                _handler.Invoke(\"set_");
                sb.Append(prop.Name);
                sb.AppendLine("\", new object?[] { value });");
                sb.AppendLine();
                // Update backing storage if property was setup with SetupProperty/SetupAllProperties
                sb.Append("                if (_handler.HasPropertyStorage(\"");
                sb.Append(prop.Name);
                sb.AppendLine("\"))");
                sb.AppendLine("                {");
                sb.Append("                    _handler.SetPropertyValue(\"");
                sb.Append(prop.Name);
                sb.AppendLine("\", value);");
                sb.AppendLine("                }");
                sb.AppendLine("            }");
                }
                
                sb.AppendLine("        }");
            }
            
            // Generate events
            sb.AppendLine(); // Add blank line before events section
            foreach (var evt in GetAllEvents(symbol))
            {
                if (symbol.TypeKind == TypeKind.Class && !evt.IsVirtual && !evt.IsAbstract && !evt.IsOverride) continue;
                
                // Determine accessibility modifier for event
                var accessibility = evt.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Protected => "protected",
                    Accessibility.Internal => "internal",
                    Accessibility.ProtectedOrInternal => "protected internal",
                    Accessibility.ProtectedAndInternal => "private protected",
                    _ => "public"
                };
                
                var modifier = symbol.TypeKind == TypeKind.Class ? "override" : "";
                var modifierStr = string.IsNullOrEmpty(modifier) ? "" : modifier + " ";
                // Include nullability annotations for events
                var eventType = evt.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                
                sb.AppendLine(); // Add blank line before each event
                sb.Append("        ");
                sb.Append(accessibility);
                sb.Append(' ');
                sb.Append(modifierStr);
                sb.Append("event ");
                sb.Append(eventType);
                sb.Append(" ");
                sb.AppendLine(evt.Name);
                sb.AppendLine("        {");
                
                // add accessor
                sb.AppendLine("            add");
                sb.AppendLine("            {");
                sb.AppendLine("                if (value != null)");
                sb.AppendLine("                {");
                sb.Append("                    _handler.AddEventHandler(\"");
                sb.Append(evt.Name);
                sb.AppendLine("\", value);");
                sb.AppendLine("                }");
                sb.AppendLine("            }");
                
                // remove accessor
                sb.AppendLine("            remove");
                sb.AppendLine("            {");
                sb.AppendLine("                if (value != null)");
                sb.AppendLine("                {");
                sb.Append("                    _handler.RemoveEventHandler(\"");
                sb.Append(evt.Name);
                sb.AppendLine("\", value);");
                sb.AppendLine("                }");
                sb.AppendLine("            }");
                
                sb.AppendLine("        }");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            spc.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateInterceptor(SourceProductionContext spc, TargetInfo target)
        {
            if (target.Symbol == null) return;
            var stableHash = GetStableHash(target.Symbol.ToDisplayString());
            var targetClassName = $"Skugga_{target.Symbol.Name}_{stableHash}";
            var interceptorName = $"Interceptor_{Guid.NewGuid().ToString("N")}";
            var filePath = target.Location.SourceTree?.FilePath; 
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;

            // Debug info removed - was causing CI build failures when TreatWarningsAsErrors is enabled
            // Console output: Intercepting {filePath}:{line} at character {charPos}

            // Determine which overload is being called based on arguments
            string methodSignature;
            string constructorCall;
            
            if (target.InvocationSyntax?.ArgumentList.Arguments.Count > 0)
            {
                var args = target.InvocationSyntax.ArgumentList.Arguments;
                
                // Check argument types by their syntax
                if (args.Count == 1)
                {
                    var argText = args[0].Expression.ToString();
                    // If argument contains "DefaultValue.", it's the DefaultValue overload
                    if (argText.Contains("DefaultValue."))
                    {
                        methodSignature = "Skugga.Core.DefaultValue defaultValue";
                        constructorCall = $"new Skugga.Generated.{targetClassName}(defaultValue)";
                    }
                    else
                    {
                        // MockBehavior only
                        methodSignature = "Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose";
                        constructorCall = $"new Skugga.Generated.{targetClassName}(behavior)";
                    }
                }
                else if (args.Count == 2)
                {
                    // Two arguments: MockBehavior, DefaultValue
                    methodSignature = "Skugga.Core.MockBehavior behavior, Skugga.Core.DefaultValue defaultValue";
                    constructorCall = $"new Skugga.Generated.{targetClassName}(behavior, defaultValue)";
                }
                else
                {
                    // Default to MockBehavior only
                    methodSignature = "Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose";
                    constructorCall = $"new Skugga.Generated.{targetClassName}(behavior)";
                }
            }
            else
            {
                // No arguments - use default MockBehavior
                methodSignature = "Skugga.Core.MockBehavior behavior = Skugga.Core.MockBehavior.Loose";
                constructorCall = $"new Skugga.Generated.{targetClassName}(behavior)";
            }

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {{
        public InterceptsLocationAttribute(string filePath, int line, int character) {{ }}
    }}
}}

namespace Skugga.Generated
{{
    public static class {interceptorName}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        public static {target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} Create({methodSignature}) 
        {{
            return {constructorCall};
        }}
    }}
}}");
            spc.AddSource($"{interceptorName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateHarness(SourceProductionContext spc, TargetInfo target)
        {
            var sutSymbol = target.Symbol;
            if (sutSymbol == null) return;
            var harnessClassName = $"Harness_{sutSymbol.Name}_{Guid.NewGuid().ToString("N").Substring(0, 8)}";
            var ctor = sutSymbol.Constructors.OrderByDescending(c => c.Parameters.Length).FirstOrDefault();
            var filePath = target.Location.SourceTree?.FilePath ?? "";
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;
            var interceptorName = $"Interceptor_{Guid.NewGuid().ToString("N")}";

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
using Skugga.Core;
using Skugga.Generated;
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute {{ public InterceptsLocationAttribute(string f, int l, int c) {{ }} }}
}}
namespace Skugga.Generated
{{
    public class {harnessClassName} : TestHarness<{sutSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>
    {{
        public {harnessClassName}()
        {{
");
            var args = new List<string>();
            if (ctor != null)
            {
                foreach (var param in ctor.Parameters)
                {
                    if (param.Type.TypeKind == TypeKind.Interface)
                    {
                        var stableHash = GetStableHash(param.Type.ToDisplayString());
                        var mockName = $"Skugga_{param.Type.Name}_{stableHash}";
                        sb.AppendLine($@"            var m_{param.Name} = new {mockName}(); _mocks[typeof({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})] = m_{param.Name};");
                        args.Add($"m_{param.Name}");
                    }
                    else args.Add("default!");
                }
            }
            sb.AppendLine($@"            SUT = new {sutSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}({string.Join(", ", args)});");
            sb.AppendLine("        } }");

            sb.AppendLine($@"
    public static class {interceptorName}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        public static TestHarness<{sutSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}> Create() => new {harnessClassName}();
    }}
}}"); 
            spc.AddSource($"{harnessClassName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateSetupVerifyInterceptor(SourceProductionContext spc, TargetInfo target)
        {
            // Generate an interceptor that replaces Setup/Verify with direct AddSetup/ValidateCall
            var interceptorName = $"Interceptor_{Guid.NewGuid().ToString("N")}";
            var filePath = target.Location.SourceTree?.FilePath ?? "";
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;

            var argsArray = target.Arguments != null && target.Arguments.Count > 0
                ? $"new object?[] {{ {string.Join(", ", target.Arguments)} }}"
                : "System.Array.Empty<object?>()";

            // TODO: For now, we can't fully intercept because Setup returns SetupContext
            // which the user then calls .Returns() on. We need to intercept the entire chain.
            // For now, just generate the code and document the limitation.
            
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
// NOTE: Setup/Verify interception is partially implemented
// The generator detects these calls but full interception requires
// intercepting the entire fluent chain (Setup().Returns().Callback())
// For now, this serves as proof that we can parse the expressions at compile-time
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {{
        public InterceptsLocationAttribute(string filePath, int line, int character) {{ }}
    }}
}}
namespace Skugga.Generated
{{
    // Detected {target.Type}: {target.MethodName}({string.Join(", ", target.Arguments ?? new List<string>())})
    // Location: {filePath}:{line}:{charPos}
    // Arguments parsed at compile-time: {argsArray}
}}");
            spc.AddSource($"{interceptorName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private void GenerateRecordingProxy(SourceProductionContext spc, TargetInfo target)
        {
            var symbol = target.Symbol;
            if (symbol == null || symbol.TypeKind != TypeKind.Interface) return;
            
            var stableHash = GetStableHash(symbol.ToDisplayString());
            var className = $"AutoScribe_{symbol.Name}_{stableHash}";
            var baseType = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Get all methods from the interface
            var methods = GetAllMethods(symbol).Where(m => m.MethodKind == MethodKind.Ordinary).ToList();
            var properties = GetAllProperties(symbol).ToList();

            var sb = new StringBuilder();
            
            // Header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS8603 // Possible null reference return");
            sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Text;");
            sb.AppendLine();
            sb.AppendLine("namespace Skugga.Generated");
            sb.AppendLine("{");
            
            // Class declaration
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// AutoScribe recording proxy for {symbol.Name}");
            sb.AppendLine($"    /// Wraps a real implementation and logs all method calls as test setup code");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {className} : {baseType}");
            sb.AppendLine("    {");
            
            // Fields
            sb.AppendLine($"        private readonly {baseType} _real;");
            sb.AppendLine("        private readonly StringBuilder _script = new();");
            sb.AppendLine("        private readonly System.Collections.Generic.List<string> _callLog = new();");
            sb.AppendLine("        private int _callCount = 0;");
            sb.AppendLine();
            
            // Constructor
            sb.AppendLine($"        public {className}({baseType} realImplementation)");
            sb.AppendLine("        {");
            sb.AppendLine("            _real = realImplementation ?? throw new ArgumentNullException(nameof(realImplementation));");
            sb.AppendLine($"            Console.WriteLine(\"// [AutoScribe] Recording started for {symbol.Name}\");");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // GetGeneratedScript method
            sb.AppendLine("        public string GetGeneratedScript() => _script.ToString();");
            sb.AppendLine();
            
            // PrintTestMethod - outputs a complete, formatted test method
            AutoScribeCodeGenerator.GeneratePrintTestMethod(sb, symbol.Name);
            
            // SerializeValue helper
            AutoScribeCodeGenerator.GenerateSerializeValueMethod(sb);
            
            // Generate interface methods
            foreach (var method in methods)
            {
                var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var paramList = string.Join(", ", method.Parameters.Select(p => 
                    $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}"));
                var argNames = string.Join(", ", method.Parameters.Select(p => p.Name));
                
                // Check if method returns Task or Task<T>
                bool isAsync = method.ReturnType.Name == "Task" || 
                               (method.ReturnType is INamedTypeSymbol nts && nts.OriginalDefinition.ToDisplayString() == "System.Threading.Tasks.Task<TResult>");
                bool isAsyncWithResult = method.ReturnType is INamedTypeSymbol namedType && 
                                         namedType.IsGenericType && 
                                         namedType.ConstructedFrom.ToDisplayString() == "System.Threading.Tasks.Task<TResult>";
                
                sb.AppendLine($"        public {(isAsync ? "async " : "")}{returnType} {method.Name}({paramList})");
                sb.AppendLine("        {");
                
                if (method.ReturnsVoid)
                {
                    sb.AppendLine($"            _real.{method.Name}({argNames});");
                    if (method.Parameters.Length > 0)
                    {
                        var args = string.Join(" + \", \" + ", method.Parameters.Select(p => $"SerializeValue({p.Name})"));
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}(\" + {args} + \"));\";");
                    }
                    else
                    {
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}());\";");
                    }
                    sb.AppendLine("            _callLog.Add(code);");
                    sb.AppendLine("            _callCount++;");
                    sb.AppendLine("            Console.WriteLine($\"// [AutoScribe] Call {_callCount}: {code}\");");
                }
                else if (isAsync && !isAsyncWithResult)
                {
                    // Task (void async)
                    sb.AppendLine($"            await _real.{method.Name}({argNames});");
                    if (method.Parameters.Length > 0)
                    {
                        var args = string.Join(" + \", \" + ", method.Parameters.Select(p => $"SerializeValue({p.Name})"));
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}(\" + {args} + \"));\";");
                    }
                    else
                    {
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}());\";");
                    }
                    sb.AppendLine("            _callLog.Add(code);");
                    sb.AppendLine("            _callCount++;");
                    sb.AppendLine("            Console.WriteLine($\"// [AutoScribe] Call {_callCount}: {code}\");");
                }
                else if (isAsyncWithResult)
                {
                    // Task<T> - await and serialize the actual result
                    sb.AppendLine($"            var result = await _real.{method.Name}({argNames});");
                    if (method.Parameters.Length > 0)
                    {
                        var args = string.Join(" + \", \" + ", method.Parameters.Select(p => $"SerializeValue({p.Name})"));
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}(\" + {args} + \")).ReturnsAsync(\" + SerializeValue(result) + \");\";");
                    }
                    else
                    {
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}()).ReturnsAsync(\" + SerializeValue(result) + \");\";");
                    }
                    sb.AppendLine("            _callLog.Add(code);");
                    sb.AppendLine("            _callCount++;");
                    sb.AppendLine("            Console.WriteLine($\"// [AutoScribe] Call {_callCount}: {code}\");");
                    sb.AppendLine("            return result;");
                }
                else
                {
                    // Sync method with return value
                    sb.AppendLine($"            var result = _real.{method.Name}({argNames});");
                    if (method.Parameters.Length > 0)
                    {
                        var args = string.Join(" + \", \" + ", method.Parameters.Select(p => $"SerializeValue({p.Name})"));
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}(\" + {args} + \")).Returns(\" + SerializeValue(result) + \");\";");
                    }
                    else
                    {
                        sb.AppendLine($"            var code = \"mock.Setup(x => x.{method.Name}()).Returns(\" + SerializeValue(result) + \");\";");
                    }
                    sb.AppendLine("            _callLog.Add(code);");
                    sb.AppendLine("            _callCount++;");
                    sb.AppendLine("            Console.WriteLine($\"// [AutoScribe] Call {_callCount}: {code}\");");
                    sb.AppendLine("            return result;");
                }
                
                sb.AppendLine("        }");
                sb.AppendLine();
            }
            
            // Generate properties
            foreach (var prop in properties)
            {
                var type = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                sb.AppendLine($"        public {type} {prop.Name}");
                sb.AppendLine("        {");
                sb.AppendLine("            get");
                sb.AppendLine("            {");
                sb.AppendLine($"                var result = _real.{prop.Name};");
                sb.AppendLine($"                var code = \"[AutoScribe] mock.Setup(x => x.{prop.Name}).Returns(\" + result + \");\";");
                sb.AppendLine("                _script.AppendLine(code);");
                sb.AppendLine("                Console.WriteLine(code);");
                sb.AppendLine("                return result;");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
            
            // Close class and namespace
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            // Generate recording proxy class
            var generatedContent = sb.ToString();
            spc.AddSource($"{className}.g.cs", SourceText.From(generatedContent, Encoding.UTF8));
        }

        private void GenerateAutoScribeInterceptor(SourceProductionContext spc, TargetInfo target)
        {
            if (target.Symbol == null) return;
            var stableHash = GetStableHash(target.Symbol.ToDisplayString());
            var targetClassName = $"AutoScribe_{target.Symbol.Name}_{stableHash}";
            var interceptorName = $"Interceptor_{Guid.NewGuid().ToString("N")}";
            var filePath = target.Location.SourceTree?.FilePath;
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;
            var fullTypeName = target.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/>
#pragma warning disable CS9270
namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {{
        public InterceptsLocationAttribute(string filePath, int line, int character) {{ }}
    }}
}}

namespace Skugga.Generated
{{
    public static class {interceptorName}
    {{
        [System.Runtime.CompilerServices.InterceptsLocation(@""{filePath}"", {line}, {charPos})]
        public static {fullTypeName} Capture({fullTypeName} realImplementation)
        {{
            return new Skugga.Generated.{targetClassName}(realImplementation);
        }}
    }}
}}");
            spc.AddSource($"{interceptorName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static IEnumerable<IMethodSymbol> GetAllMethods(INamedTypeSymbol symbol) { return symbol.GetMembers().OfType<IMethodSymbol>().Concat(symbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IMethodSymbol>())); }
        private static IEnumerable<IPropertySymbol> GetAllProperties(INamedTypeSymbol symbol) { return symbol.GetMembers().OfType<IPropertySymbol>().Concat(symbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IPropertySymbol>())); }
        private static IEnumerable<IEventSymbol> GetAllEvents(INamedTypeSymbol symbol) { return symbol.GetMembers().OfType<IEventSymbol>().Concat(symbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IEventSymbol>())); }
        
        /// <summary>
        /// Returns appropriate default value for a type, with special handling for Task types.
        /// </summary>
        private static string GetDefaultValueForType(ITypeSymbol returnType, string returnTypeDisplayString)
        {
            // Check if it's a generic type parameter (T, TInput, TOutput, etc.)
            if (returnType.TypeKind == TypeKind.TypeParameter)
            {
                // For generic type parameters, use default(T)!
                return $"default({returnTypeDisplayString})!";
            }
            
            // Check if it's Task (void async)
            if (returnType.Name == "Task" && returnType.ContainingNamespace?.ToDisplayString() == "System.Threading.Tasks")
            {
                // Check if it's generic Task<T>
                if (returnType is INamedTypeSymbol namedType && namedType.IsGenericType)
                {
                    // Task<T> - return Task.FromResult(default(T))
                    var typeArg = namedType.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    return $"global::System.Threading.Tasks.Task.FromResult<{typeArg}>(default({typeArg})!)";
                }
                else
                {
                    // Task - return Task.CompletedTask
                    return "global::System.Threading.Tasks.Task.CompletedTask";
                }
            }
            
            // Check if it's ValueTask
            if (returnType.Name == "ValueTask" && returnType.ContainingNamespace?.ToDisplayString() == "System.Threading.Tasks")
            {
                if (returnType is INamedTypeSymbol namedType && namedType.IsGenericType)
                {
                    // ValueTask<T>
                    var typeArg = namedType.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    return $"global::System.Threading.Tasks.ValueTask.FromResult<{typeArg}>(default({typeArg})!)";
                }
                else
                {
                    // ValueTask
                    return "default(global::System.Threading.Tasks.ValueTask)";
                }
            }
            
            // Default behavior for non-Task types
            return returnType.IsReferenceType ? "null!" : $"default({returnTypeDisplayString})";
        }
        
        enum TargetType { Mock, Harness, Setup, Verify, AutoScribe }
        class TargetInfo 
        { 
            public INamedTypeSymbol? Symbol; 
            public Location Location; 
            public TargetType Type; 
            public ExpressionSyntax? LambdaExpression; 
            public InvocationExpressionSyntax? InvocationSyntax;
            public string? MethodName;
            public List<string>? Arguments;
            public bool IsProperty;
            
            public TargetInfo(INamedTypeSymbol? s, Location l, TargetType t, ExpressionSyntax? lambda = null, 
                InvocationExpressionSyntax? invocation = null, string? methodName = null, 
                List<string>? args = null, bool isProperty = false) 
            { 
                Symbol=s; 
                Location=l; 
                Type=t; 
                LambdaExpression=lambda; 
                InvocationSyntax=invocation;
                MethodName=methodName;
                Arguments=args;
                IsProperty=isProperty;
            } 
        }

        /// <summary>
        /// Generates a stable hash for a string using FNV-1a algorithm.
        /// This ensures consistent hashes across builds and machines.
        /// </summary>
        private static string GetStableHash(string text)
        {
            // FNV-1a parameters for 32-bit hash
            const uint fnvPrime = 0x01000193;
            uint hash = 0x811c9dc5;

            foreach (char c in text)
            {
                hash ^= c;
                hash *= fnvPrime;
            }

            return hash.ToString();
        }
    }
}