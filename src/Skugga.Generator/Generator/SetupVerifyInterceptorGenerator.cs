#nullable enable
using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Skugga.Generator.GeneratorHelpers;

namespace Skugga.Generator
{
    internal static class SetupVerifyInterceptorGenerator
    {
        public static void GenerateSetupVerifyInterceptor(SourceProductionContext spc, TargetInfo target)
        {
            var symbol = target.Symbol;
            if (symbol == null) return;
            var filePath = target.Location.SourceTree?.FilePath ?? "";
            var lineSpan = target.Location.GetLineSpan();
            var line = lineSpan.StartLinePosition.Line + 1;
            var charPos = lineSpan.StartLinePosition.Character + 1;

            var uniqueId = GetStableHash($"{filePath}_{line}_{charPos}");
            var interceptorName = $"Interceptor_{symbol.Name}_{target.MethodName}_{uniqueId}";

            var argValues = new List<string>();
            if (target.Arguments != null && target.LambdaExpression is LambdaExpressionSyntax lambda)
            {
                var body = lambda.Body;
                if (body is InvocationExpressionSyntax invocation)
                {
                    for (int i = 0; i < target.Arguments.Count; i++)
                    {
                        var arg = target.Arguments[i];
                        switch (arg.Kind)
                        {
                            case ArgumentKind.Value:
                                argValues.Add(arg.ValueOrExpression);
                                break;
                            case ArgumentKind.MatcherIsAny:
                                argValues.Add($"new global::Skugga.Core.ArgumentMatcher<{arg.ValueOrExpression}>(_ => true, \"It.IsAny<{arg.ValueOrExpression}>()\")");
                                break;
                            case ArgumentKind.MatcherIs:
                                argValues.Add($"new global::Skugga.Core.ArgumentMatcher<{arg.ValueOrExpression}>({arg.Predicate}, \"It.Is<{arg.ValueOrExpression}>(...)\")");
                                break;
                            case ArgumentKind.Expression:
                            default:
                                argValues.Add($"global::Skugga.Core.MockExtensions.GetArgumentValue(((global::System.Linq.Expressions.MethodCallExpression)((global::System.Linq.Expressions.LambdaExpression)_).Body).Arguments[{i}])");
                                break;
                        }
                    }
                }
                else if (body is AssignmentExpressionSyntax assignment)
                {
                    var arg = target.Arguments[0];
                    switch (arg.Kind)
                    {
                        case ArgumentKind.Value:
                            argValues.Add(arg.ValueOrExpression);
                            break;
                        case ArgumentKind.MatcherIsAny:
                            argValues.Add($"new global::Skugga.Core.ArgumentMatcher<{arg.ValueOrExpression}>(_ => true, \"It.IsAny<{arg.ValueOrExpression}>()\")");
                            break;
                        case ArgumentKind.MatcherIs:
                            argValues.Add($"new global::Skugga.Core.ArgumentMatcher<{arg.ValueOrExpression}>({arg.Predicate}, \"It.Is<{arg.ValueOrExpression}>(...)\")");
                            break;
                        case ArgumentKind.Expression:
                        default:
                            argValues.Add($"global::Skugga.Core.MockExtensions.GetArgumentValue(((global::System.Linq.Expressions.BinaryExpression)((global::System.Linq.Expressions.LambdaExpression)_).Body).Right)");
                            break;
                    }
                }
            }

            var argsArray = argValues.Count > 0
                ? $"new object?[] {{ {string.Join(", ", argValues)} }}"
                : "global::System.Array.Empty<object?>()";

            var fullTypeName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isSetup = target.Type == TargetType.Setup;

            var sb = new StringBuilder(1024);
            sb.AppendLine(AutoGeneratedComment);
            sb.AppendLine(NullableEnable);
            sb.AppendLine("#pragma warning disable CS9270");
            sb.AppendLine("namespace System.Runtime.CompilerServices");
            sb.AppendLine("{");
            sb.AppendLine("    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
            sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
            sb.AppendLine("    {");
            sb.AppendLine("        public InterceptsLocationAttribute(string filePath, int line, int character) { }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine(SkuggaGeneratedNamespace);
            sb.AppendLine("{");
            sb.AppendLine($"    public static class {interceptorName}");
            sb.AppendLine("    {");
            sb.AppendLine($"        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(@\"{filePath}\", {line}, {charPos})]");

            if (target.Type == TargetType.SetupSet)
            {
                sb.AppendLine($@"        public static global::Skugga.Core.VoidSetupContext<{fullTypeName}> SetupSet(this {fullTypeName} mock, global::System.Action<{fullTypeName}> _)
        {{
            var handler = ((global::Skugga.Core.IMockSetup)mock).Handler;
            var args = {argsArray};
            var setup = handler.AddSetup(""{target.MethodName}"", args, null, null);
            return new global::Skugga.Core.VoidSetupContext<{fullTypeName}>(handler, ""{target.MethodName}"", args, setup);
        }}");
            }
            else if (target.Type == TargetType.VerifySet)
            {
                sb.AppendLine($@"        public static void VerifySet(this {fullTypeName} mock, global::System.Action<{fullTypeName}> _, global::Skugga.Core.Times? times = null)
        {{
            var handler = ((global::Skugga.Core.IMockSetup)mock).Handler;
            var args = {argsArray};
            handler.Verify(""{target.MethodName}"", args, times ?? global::Skugga.Core.Times.AtLeast(1), null);
        }}");
            }
            else if (isSetup)
            {
                if (target.IsRecursive)
                {
                    if (target.IsFunc)
                    {
                        sb.AppendLine($@"        public static global::Skugga.Core.SetupContext<{fullTypeName}, TResult> Setup<T, TResult>(this {fullTypeName} mock, global::System.Linq.Expressions.Expression<global::System.Func<{fullTypeName}, TResult>> expr)
        {{
            return global::Skugga.Core.MockExtensions.Setup(mock, expr);
        }}");
                    }
                    else
                    {
                        sb.AppendLine($@"        public static global::Skugga.Core.VoidSetupContext<{fullTypeName}> Setup<T>(this {fullTypeName} mock, global::System.Linq.Expressions.Expression<global::System.Action<{fullTypeName}>> expr)
        {{
            return global::Skugga.Core.MockExtensions.Setup(mock, expr);
        }}");
                    }
                }
                else if (target.IsFunc)
                {
                    sb.AppendLine($@"        public static global::Skugga.Core.SetupContext<{fullTypeName}, TResult> Setup<T, TResult>(this {fullTypeName} mock, global::System.Linq.Expressions.Expression<global::System.Func<{fullTypeName}, TResult>> _)
        {{
            var handler = ((global::Skugga.Core.IMockSetup)mock).Handler;
            var args = {argsArray};
            var setup = handler.AddSetup(""{target.MethodName}"", args, default(TResult), null);
            return new global::Skugga.Core.SetupContext<{fullTypeName}, TResult>(handler, ""{target.MethodName}"", args, setup);
        }}");
                }
                else
                {
                    sb.AppendLine($@"        public static global::Skugga.Core.VoidSetupContext<{fullTypeName}> Setup<T>(this {fullTypeName} mock, global::System.Linq.Expressions.Expression<global::System.Action<{fullTypeName}>> _)
        {{
            var handler = ((global::Skugga.Core.IMockSetup)mock).Handler;
            var args = {argsArray};
            var setup = handler.AddSetup(""{target.MethodName}"", args, null, null);
            return new global::Skugga.Core.VoidSetupContext<{fullTypeName}>(handler, ""{target.MethodName}"", args, setup);
        }}");
                }
            }
            else
            {
                // Detect ref/out parameters for verification
                var refOutIndices = new List<int>();
                if (target.Arguments != null)
                {
                    for (int i = 0; i < target.Arguments.Count; i++)
                    {
                        if (target.Arguments[i].IsRefOrOut)
                        {
                            refOutIndices.Add(i);
                        }
                    }
                }

                var refOutIndicesCode = refOutIndices.Count > 0
                    ? $"new global::System.Collections.Generic.HashSet<int> {{ {string.Join(", ", refOutIndices)} }}"
                    : "null";

                if (target.IsFunc)
                {
                    sb.AppendLine($@"        public static void Verify<T, TResult>(this {fullTypeName} mock, global::System.Linq.Expressions.Expression<global::System.Func<{fullTypeName}, TResult>> _, global::Skugga.Core.Times? times = null)
        {{
            var handler = ((global::Skugga.Core.IMockSetup)mock).Handler;
            var args = {argsArray};
            handler.Verify(""{target.MethodName}"", args, times ?? global::Skugga.Core.Times.AtLeast(1), {refOutIndicesCode});
        }}");
                }
                else
                {
                    sb.AppendLine($@"        public static void Verify<T>(this {fullTypeName} mock, global::System.Linq.Expressions.Expression<global::System.Action<{fullTypeName}>> _, global::Skugga.Core.Times? times = null)
        {{
            var handler = ((global::Skugga.Core.IMockSetup)mock).Handler;
            var args = {argsArray};
            handler.Verify(""{target.MethodName}"", args, times ?? global::Skugga.Core.Times.AtLeast(1), {refOutIndicesCode});
        }}");
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            spc.AddSource($"{interceptorName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}
