using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Skugga.Core.Generators;

/// <summary>
/// Source generator that creates Returns/ReturnsAsync overloads for different argument counts.
/// Eliminates manual boilerplate by generating extension methods at compile time.
/// </summary>
[Generator]
public class SetupExtensionsGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization needed
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var maxArgs = 8; // Support up to 8 arguments (covers 99.9% of use cases)
        
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine("namespace Skugga.Core");
        sb.AppendLine("{");
        sb.AppendLine("    public static partial class SetupContextExtensions");
        sb.AppendLine("    {");

        // Generate Returns overloads (4-8 arguments, since we have 0-3 manually)
        for (int argCount = 4; argCount <= maxArgs; argCount++)
        {
            GenerateReturnsOverload(sb, argCount);
        }

        // Generate ReturnsAsync overloads (3-8 arguments, since we have 0-2 manually)
        for (int argCount = 3; argCount <= maxArgs; argCount++)
        {
            GenerateReturnsAsyncOverload(sb, argCount);
        }
        
        // Generate Callback overloads (4-8 arguments, since we have 0-3 manually)
        for (int argCount = 4; argCount <= maxArgs; argCount++)
        {
            GenerateCallbackOverload(sb, argCount, forVoidContext: false);
        }
        
        // Generate Callback overloads for VoidSetupContext (4-8 arguments, since we have 0-3 manually)
        for (int argCount = 4; argCount <= maxArgs; argCount++)
        {
            GenerateCallbackOverload(sb, argCount, forVoidContext: true);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("SetupContextExtensions.Generated.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private void GenerateReturnsOverload(StringBuilder sb, int argCount)
    {
        var typeParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"TArg{i}"));
        var funcParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"(TArg{i})args[{i-1}]!"));
        var argList = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"arg{i}"));
        
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Configures the setup to return a value computed from {argCount} method arguments.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static SetupContext<TMock, TResult> Returns<TMock, TResult, {typeParams}>(");
        sb.AppendLine($"            this SetupContext<TMock, TResult> context, Func<{typeParams}, TResult> valueFunction)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (context.Setup == null)");
        sb.AppendLine("            {");
        sb.AppendLine("                context.Setup = context.Handler.AddSetup(context.Signature, context.Args, default(TResult), null);");
        sb.AppendLine($"                context.Setup.ValueFactory = args => valueFunction({funcParams});");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup.ValueFactory = args => valueFunction({funcParams});");
        sb.AppendLine("            }");
        sb.AppendLine("            return context;");
        sb.AppendLine("        }");
    }

    private void GenerateReturnsAsyncOverload(StringBuilder sb, int argCount)
    {
        var typeParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"TArg{i}"));
        var funcParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"(TArg{i})args[{i-1}]!"));
        
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Configures the setup to return a Task<TResult> computed from {argCount} method arguments (async shorthand).");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static SetupContext<TMock, Task<TResult>> ReturnsAsync<TMock, TResult, {typeParams}>(");
        sb.AppendLine($"            this SetupContext<TMock, Task<TResult>> context, Func<{typeParams}, TResult> valueFunction)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (context.Setup == null)");
        sb.AppendLine("            {");
        sb.AppendLine("                context.Setup = context.Handler.AddSetup(context.Signature, context.Args, default(Task<TResult>), null);");
        sb.AppendLine($"                context.Setup.ValueFactory = args => Task.FromResult(valueFunction({funcParams}));");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup.ValueFactory = args => Task.FromResult(valueFunction({funcParams}));");
        sb.AppendLine("            }");
        sb.AppendLine("            return context;");
        sb.AppendLine("        }");
    }
    
    private void GenerateCallbackOverload(StringBuilder sb, int argCount, bool forVoidContext)
    {
        var typeParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"TArg{i}"));
        var callbackParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"(TArg{i})args[{i-1}]!"));
        var contextType = forVoidContext ? "VoidSetupContext<TMock>" : "SetupContext<TMock, TResult>";
        var returnType = forVoidContext ? "VoidSetupContext<TMock>" : "SetupContext<TMock, TResult>";
        var genericConstraint = forVoidContext ? "TMock" : "TMock, TResult";
        var defaultValue = forVoidContext ? "null" : "default(TResult)!";
        
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Configures a callback with access to {argCount} method arguments when invoked.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static {returnType} Callback<{genericConstraint}, {typeParams}>(");
        sb.AppendLine($"            this {contextType} context, Action<{typeParams}> callback)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (context.Setup == null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup = context.Handler.AddSetup(context.Signature, context.Args, {defaultValue}, args => callback({callbackParams}));");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup.Callback = args => callback({callbackParams});");
        sb.AppendLine("            }");
        sb.AppendLine("            return context;");
        sb.AppendLine("        }");
    }
}
