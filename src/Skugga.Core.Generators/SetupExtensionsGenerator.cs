using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Skugga.Core.Generators;

/// <summary>
/// Roslyn source generator that creates Returns/ReturnsAsync/Callback extension method overloads for 4-8 argument methods.
/// Eliminates manual boilerplate by generating code at compile time using C# Source Generators.
/// </summary>
/// <remarks>
/// <para>
/// This generator creates extension methods for SetupContext and VoidSetupContext that handle methods with 4-8 parameters.
/// Manual overloads (0-3 parameters) are defined in SetupContextExtensions.cs for common cases.
/// </para>
/// <para>
/// Generated methods include:
/// - Returns: Configure return values computed from method arguments
/// - ReturnsAsync: Configure async return values (Task&lt;T&gt;) from method arguments
/// - Callback: Configure side effects with access to method arguments
/// </para>
/// <para>
/// Example generated code:
/// <code>
/// public static SetupContext&lt;TMock, TResult&gt; Returns&lt;TMock, TResult, TArg1, TArg2, TArg3, TArg4&gt;(
///     this SetupContext&lt;TMock, TResult&gt; context, 
///     Func&lt;TArg1, TArg2, TArg3, TArg4, TResult&gt; valueFunction)
/// {
///     // Implementation that wraps valueFunction with argument extraction
/// }
/// </code>
/// </para>
/// </remarks>
[Generator]
public class SetupExtensionsGenerator : ISourceGenerator
{
    /// <summary>
    /// Called to initialize the generator. No initialization is required for this generator.
    /// </summary>
    /// <param name="context">Context for generator initialization</param>
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization needed - this generator is stateless
    }

    /// <summary>
    /// Called by the compiler to generate source code for extension method overloads.
    /// Generates Returns, ReturnsAsync, and Callback methods for 4-8 argument methods.
    /// </summary>
    /// <param name="context">Context providing access to compilation and ability to add generated source</param>
    public void Execute(GeneratorExecutionContext context)
    {
        // Generate overloads for 4-8 arguments (0-3 are manually defined for better IDE experience)
        // This covers 99.9% of real-world use cases while keeping manual code manageable
        var maxArgs = 8;
        
        var sb = new StringBuilder();
        
        // Add file header with auto-generated marker
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// This file is generated by SetupExtensionsGenerator.cs at compile time.");
        sb.AppendLine("// Do not modify this file directly - changes will be overwritten on next build.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine("namespace Skugga.Core");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Generated extension methods for SetupContext and VoidSetupContext (4-8 arguments).");
        sb.AppendLine("    /// This is a partial class - manual overloads (0-3 args) are in SetupContextExtensions.cs.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static partial class SetupContextExtensions");
        sb.AppendLine("    {");

        // Generate Returns overloads for non-void methods (4-8 arguments)
        // Manual overloads exist for 0-3 arguments
        for (int argCount = 4; argCount <= maxArgs; argCount++)
        {
            GenerateReturnsOverload(sb, argCount);
        }

        // Generate ReturnsAsync overloads for async methods (3-8 arguments)
        // Manual overloads exist for 0-2 arguments
        for (int argCount = 3; argCount <= maxArgs; argCount++)
        {
            GenerateReturnsAsyncOverload(sb, argCount);
        }
        
        // Generate Callback overloads for non-void methods (4-8 arguments)
        // Manual overloads exist for 0-3 arguments
        for (int argCount = 4; argCount <= maxArgs; argCount++)
        {
            GenerateCallbackOverload(sb, argCount, forVoidContext: false);
        }
        
        // Generate Callback overloads for void methods (4-8 arguments)
        // Manual overloads exist for 0-3 arguments
        for (int argCount = 4; argCount <= maxArgs; argCount++)
        {
            GenerateCallbackOverload(sb, argCount, forVoidContext: true);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        // Add generated source to compilation
        context.AddSource("SetupContextExtensions.Generated.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Generates a Returns overload for methods with the specified number of arguments.
    /// Creates an extension method that accepts a Func with typed arguments and wraps it with argument extraction logic.
    /// </summary>
    /// <param name="sb">StringBuilder to append generated code to</param>
    /// <param name="argCount">Number of method arguments (4-8)</param>
    /// <example>
    /// For argCount=4, generates:
    /// <code>
    /// public static SetupContext&lt;TMock, TResult&gt; Returns&lt;TMock, TResult, TArg1, TArg2, TArg3, TArg4&gt;(
    ///     this SetupContext&lt;TMock, TResult&gt; context, 
    ///     Func&lt;TArg1, TArg2, TArg3, TArg4, TResult&gt; valueFunction)
    /// </code>
    /// </example>
    private void GenerateReturnsOverload(StringBuilder sb, int argCount)
    {
        // Create type parameter list: TArg1, TArg2, ..., TArgN
        var typeParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"TArg{i}"));
        
        // Create argument extraction: (TArg1)args[0]!, (TArg2)args[1]!, ...
        // The null-forgiving operator (!) is safe because the mock framework ensures args are populated
        var funcParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"(TArg{i})args[{i-1}]!"));
        
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Configures the setup to return a value computed from {argCount} method arguments.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static SetupContext<TMock, TResult> Returns<TMock, TResult, {typeParams}>(");
        sb.AppendLine($"            this SetupContext<TMock, TResult> context, Func<{typeParams}, TResult> valueFunction)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (context.Setup == null)");
        sb.AppendLine("            {");
        sb.AppendLine("                context.Setup = context.Handler.AddSetup(context.Signature, context.Args, default(TResult), null);");
        sb.AppendLine($"                context.Setup.ValueFactory = args => valueFunction({funcParams});");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup.ValueFactory = args => valueFunction({funcParams});");
        sb.AppendLine("            }");
        sb.AppendLine("            return context;");
        sb.AppendLine("        }");
    }

    /// <summary>
    /// Generates a ReturnsAsync overload for async methods with the specified number of arguments.
    /// Creates an extension method that accepts a Func returning TResult and wraps it with Task.FromResult.
    /// </summary>
    /// <param name="sb">StringBuilder to append generated code to</param>
    /// <param name="argCount">Number of method arguments (3-8)</param>
    /// <remarks>
    /// ReturnsAsync is a convenience method for async methods. Instead of:
    /// <code>mock.Setup(m => m.GetAsync(x)).Returns(args => Task.FromResult(value))</code>
    /// Users can write:
    /// <code>mock.Setup(m => m.GetAsync(x)).ReturnsAsync(args => value)</code>
    /// </remarks>
    private void GenerateReturnsAsyncOverload(StringBuilder sb, int argCount)
    {
        // Create type parameter list: TArg1, TArg2, ..., TArgN
        var typeParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"TArg{i}"));
        
        // Create argument extraction for async wrapper
        var funcParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"(TArg{i})args[{i-1}]!"));
        
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Configures the setup to return a Task<TResult> computed from {argCount} method arguments (async shorthand).");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static SetupContext<TMock, Task<TResult>> ReturnsAsync<TMock, TResult, {typeParams}>(");
        sb.AppendLine($"            this SetupContext<TMock, Task<TResult>> context, Func<{typeParams}, TResult> valueFunction)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (context.Setup == null)");
        sb.AppendLine("            {");
        sb.AppendLine("                context.Setup = context.Handler.AddSetup(context.Signature, context.Args, default(Task<TResult>), null);");
        sb.AppendLine($"                context.Setup.ValueFactory = args => Task.FromResult(valueFunction({funcParams}));");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup.ValueFactory = args => Task.FromResult(valueFunction({funcParams}));");
        sb.AppendLine("            }");
        sb.AppendLine("            return context;");
        sb.AppendLine("        }");
    }
    
    /// <summary>
    /// Generates a Callback overload for methods with the specified number of arguments.
    /// Creates an extension method that accepts an Action with typed arguments for side effects.
    /// </summary>
    /// <param name="sb">StringBuilder to append generated code to</param>
    /// <param name="argCount">Number of method arguments (4-8)</param>
    /// <param name="forVoidContext">True to generate for VoidSetupContext (void methods), false for SetupContext (non-void methods)</param>
    /// <remarks>
    /// Callbacks allow executing custom logic when a mocked method is invoked, useful for:
    /// - Tracking invocations
    /// - Modifying state
    /// - Performing validations
    /// - Triggering other operations
    /// </remarks>
    private void GenerateCallbackOverload(StringBuilder sb, int argCount, bool forVoidContext)
    {
        // Create type parameter list: TArg1, TArg2, ..., TArgN
        var typeParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"TArg{i}"));
        
        // Create argument extraction for callback: (TArg1)args[0]!, (TArg2)args[1]!, ...
        var callbackParams = string.Join(", ", Enumerable.Range(1, argCount).Select(i => $"(TArg{i})args[{i-1}]!"));
        
        // Determine context types based on whether this is for void or non-void methods
        var contextType = forVoidContext ? "VoidSetupContext<TMock>" : "SetupContext<TMock, TResult>";
        var returnType = forVoidContext ? "VoidSetupContext<TMock>" : "SetupContext<TMock, TResult>";
        var genericConstraint = forVoidContext ? "TMock" : "TMock, TResult";
        
        // Void methods don't need a return value, non-void methods use default(TResult)
        var defaultValue = forVoidContext ? "null" : "default(TResult)!";
        
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Configures a callback with access to {argCount} method arguments when invoked.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static {returnType} Callback<{genericConstraint}, {typeParams}>(");
        sb.AppendLine($"            this {contextType} context, Action<{typeParams}> callback)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (context.Setup == null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup = context.Handler.AddSetup(context.Signature, context.Args, {defaultValue}, args => callback({callbackParams}));");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                context.Setup.Callback = args => callback({callbackParams});");
        sb.AppendLine("            }");
        sb.AppendLine("            return context;");
        sb.AppendLine("        }");
    }
}
