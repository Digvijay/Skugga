using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.OpenApi.Models;

namespace Skugga.OpenApi.Generator
{
    /// <summary>
    /// Generates C# classes from OpenAPI component schemas.
    /// Handles properties, required fields, and $ref resolution.
    /// </summary>
    internal class SchemaGenerator
    {
        private readonly TypeMapper _typeMapper;

        public SchemaGenerator(TypeMapper typeMapper)
        {
            _typeMapper = typeMapper ?? throw new ArgumentNullException(nameof(typeMapper));
        }

        /// <summary>
        /// Generates C# classes for all component schemas.
        /// </summary>
        /// <param name="namespaceName">The namespace for the generated classes</param>
        /// <param name="prefix">Optional prefix for schema class names (null or empty for no prefix)</param>
        public string GenerateSchemas(string namespaceName, string? prefix = null)
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// This file is generated by SkuggaOpenApiGenerator");
            sb.AppendLine("// DO NOT EDIT: Changes will be overwritten on next build");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();

            // Namespace
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");

            // Track generated classes to avoid duplicates
            var generatedClasses = new HashSet<string>();

            // Generate each schema with optional prefix
            foreach (var schemaEntry in _typeMapper.GetComponentSchemas())
            {
                var className = string.IsNullOrEmpty(prefix) ? schemaEntry.Key : prefix + "_" + schemaEntry.Key;
                GenerateSchemaAndSubtypes(sb, className, schemaEntry.Value, generatedClasses, prefix);
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Generates a schema and all its subtypes (oneOf/anyOf/allOf).
        /// </summary>
        private void GenerateSchemaAndSubtypes(StringBuilder sb, string className, OpenApiSchema schema, HashSet<string> generatedClasses, string? prefix)
        {
            if (generatedClasses.Contains(className))
                return;

            // Handle allOf - generate all referenced schemas first, then the composite
            if (schema.AllOf != null && schema.AllOf.Any())
            {
                foreach (var subSchema in schema.AllOf)
                {
                    if (subSchema.Reference != null)
                    {
                        var refName = GetTypeNameFromReference(subSchema.Reference.Id);
                        var prefixedRefName = string.IsNullOrEmpty(prefix) ? refName : prefix + "_" + refName;
                        var refSchema = _typeMapper.GetComponentSchemas().FirstOrDefault(s => s.Key == refName).Value;
                        if (refSchema != null)
                        {
                            GenerateSchemaAndSubtypes(sb, prefixedRefName, refSchema, generatedClasses, prefix);
                        }
                    }
                }

                // Generate the composite class (if it has its own properties or should be generated)
                if (_typeMapper.ShouldGenerateClass(schema))
                {
                    GenerateClass(sb, className, schema);
                    generatedClasses.Add(className);
                    sb.AppendLine();
                }
                return;
            }

            // Handle oneOf - generate each option as a separate class
            if (schema.OneOf != null && schema.OneOf.Any())
            {
                foreach (var subSchema in schema.OneOf)
                {
                    if (subSchema.Reference != null)
                    {
                        var refName = GetTypeNameFromReference(subSchema.Reference.Id);
                        var prefixedRefName = string.IsNullOrEmpty(prefix) ? refName : prefix + "_" + refName;
                        var refSchema = _typeMapper.GetComponentSchemas().FirstOrDefault(s => s.Key == refName).Value;
                        if (refSchema != null)
                        {
                            GenerateSchemaAndSubtypes(sb, prefixedRefName, refSchema, generatedClasses, prefix);
                        }
                    }
                }

                // Generate base class if it has discriminator or properties
                if (schema.Discriminator != null || schema.Properties?.Any() == true)
                {
                    GenerateClass(sb, className, schema);
                    generatedClasses.Add(className);
                    sb.AppendLine();
                }
                return;
            }

            // Handle anyOf - similar to oneOf
            if (schema.AnyOf != null && schema.AnyOf.Any())
            {
                foreach (var subSchema in schema.AnyOf)
                {
                    if (subSchema.Reference != null)
                    {
                        var refName = GetTypeNameFromReference(subSchema.Reference.Id);
                        var prefixedRefName = string.IsNullOrEmpty(prefix) ? refName : prefix + "_" + refName;
                        var refSchema = _typeMapper.GetComponentSchemas().FirstOrDefault(s => s.Key == refName).Value;
                        if (refSchema != null)
                        {
                            GenerateSchemaAndSubtypes(sb, prefixedRefName, refSchema, generatedClasses, prefix);
                        }
                    }
                }

                // Generate base class (empty if no properties, for type compatibility)
                GenerateClass(sb, className, schema);
                generatedClasses.Add(className);
                sb.AppendLine();
                return;
            }

            // Regular schema - generate if it should be a class
            if (_typeMapper.ShouldGenerateClass(schema))
            {
                GenerateClass(sb, className, schema);
                generatedClasses.Add(className);
                sb.AppendLine();
            }
        }

        /// <summary>
        /// Gets the type name from a reference ID.
        /// </summary>
        private string GetTypeNameFromReference(string referenceId)
        {
            if (string.IsNullOrEmpty(referenceId))
                return "object";

            // Reference format: #/components/schemas/TypeName
            var parts = referenceId.Split('/');
            return parts.Length > 0 ? parts[parts.Length - 1] : referenceId;
        }

        /// <summary>
        /// Generates a single C# class from an OpenAPI schema.
        /// </summary>
        private void GenerateClass(StringBuilder sb, string className, OpenApiSchema schema)
        {
            // Handle allOf by merging properties
            if (schema.AllOf != null && schema.AllOf.Any())
            {
                GenerateAllOfClass(sb, className, schema);
                return;
            }

            // XML documentation
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXmlDoc(schema.Description ?? className)}");
            sb.AppendLine("    /// </summary>");

            // Class declaration
            sb.AppendLine($"    public class {className}");
            sb.AppendLine("    {");

            // Generate properties
            if (schema.Properties != null && schema.Properties.Any())
            {
                var requiredProps = schema.Required != null
                    ? new HashSet<string>(schema.Required)
                    : new HashSet<string>();

                foreach (var prop in schema.Properties)
                {
                    GenerateProperty(sb, prop.Key, prop.Value, requiredProps.Contains(prop.Key));
                }
            }

            sb.AppendLine("    }");
        }

        /// <summary>
        /// Generates a class with allOf inheritance - merges all properties.
        /// </summary>
        private void GenerateAllOfClass(StringBuilder sb, string className, OpenApiSchema schema)
        {
            // XML documentation
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXmlDoc(schema.Description ?? className)}");
            sb.AppendLine("    /// </summary>");

            // Class declaration
            sb.AppendLine($"    public class {className}");
            sb.AppendLine("    {");

            // Merge properties from all allOf schemas
            var allProperties = new Dictionary<string, (OpenApiSchema schema, bool isRequired)>();
            var allRequired = new HashSet<string>();

            foreach (var subSchema in schema.AllOf)
            {
                // Add required fields
                if (subSchema.Required != null)
                {
                    foreach (var req in subSchema.Required)
                        allRequired.Add(req);
                }

                // Add properties
                if (subSchema.Properties != null)
                {
                    foreach (var prop in subSchema.Properties)
                    {
                        if (!allProperties.ContainsKey(prop.Key))
                            allProperties[prop.Key] = (prop.Value, allRequired.Contains(prop.Key));
                    }
                }

                // Handle referenced schemas
                if (subSchema.Reference != null)
                {
                    var refName = GetTypeNameFromReference(subSchema.Reference.Id);
                    var refSchema = _typeMapper.GetComponentSchemas().FirstOrDefault(s => s.Key == refName).Value;
                    if (refSchema?.Properties != null)
                    {
                        if (refSchema.Required != null)
                        {
                            foreach (var req in refSchema.Required)
                                allRequired.Add(req);
                        }

                        foreach (var prop in refSchema.Properties)
                        {
                            if (!allProperties.ContainsKey(prop.Key))
                                allProperties[prop.Key] = (prop.Value, allRequired.Contains(prop.Key));
                        }
                    }
                }
            }

            // Add properties from the schema itself
            if (schema.Required != null)
            {
                foreach (var req in schema.Required)
                    allRequired.Add(req);
            }

            if (schema.Properties != null)
            {
                foreach (var prop in schema.Properties)
                {
                    if (!allProperties.ContainsKey(prop.Key))
                        allProperties[prop.Key] = (prop.Value, allRequired.Contains(prop.Key));
                }
            }

            // Generate all merged properties
            foreach (var prop in allProperties)
            {
                GenerateProperty(sb, prop.Key, prop.Value.schema, prop.Value.isRequired);
            }

            sb.AppendLine("    }");
        }

        /// <summary>
        /// Generates a single property in a class.
        /// </summary>
        private void GenerateProperty(StringBuilder sb, string propertyName, OpenApiSchema propertySchema, bool isRequired)
        {
            var propName = ToPascalCase(propertyName);
            var propType = _typeMapper.MapType(propertySchema, null, !isRequired);

            // XML documentation
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine($"        /// {EscapeXmlDoc(propertySchema.Description ?? propName)}");
            sb.AppendLine("        /// </summary>");

            // Handle example if available
            if (propertySchema.Example != null)
            {
                sb.AppendLine($"        /// <example>{EscapeXmlDoc(propertySchema.Example.ToString())}</example>");
            }

            // Property declaration
            // Add initializer for reference types to avoid nullability warnings
            if (!IsValueType(propType) && !propType.EndsWith("?"))
            {
                if (propType.EndsWith("[]"))
                {
                    sb.AppendLine($"        public {propType} {propName} {{ get; set; }} = Array.Empty<{propType.TrimEnd('[', ']')}>();");
                }
                else if (propType.StartsWith("List<"))
                {
                    sb.AppendLine($"        public {propType} {propName} {{ get; set; }} = new {propType}();");
                }
                else if (propType == "string")
                {
                    sb.AppendLine($"        public {propType} {propName} {{ get; set; }} = string.Empty;");
                }
                else
                {
                    // For custom classes, make nullable if not required
                    if (!isRequired)
                    {
                        sb.AppendLine($"        public {propType}? {propName} {{ get; set; }}");
                    }
                    else
                    {
                        sb.AppendLine($"        public {propType} {propName} {{ get; set; }} = new {propType}();");
                    }
                }
            }
            else
            {
                sb.AppendLine($"        public {propType} {propName} {{ get; set; }}");
            }
        }

        /// <summary>
        /// Converts a string to PascalCase.
        /// </summary>
        private string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            var parts = input.Split(new[] { '_', '-', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            var sb = new StringBuilder();

            foreach (var part in parts)
            {
                if (part.Length > 0)
                {
                    sb.Append(char.ToUpperInvariant(part[0]));
                    if (part.Length > 1)
                        sb.Append(part.Substring(1));
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Determines if a type is a value type.
        /// </summary>
        private bool IsValueType(string typeName)
        {
            return typeName switch
            {
                "int" or "long" or "short" or "byte" or "sbyte" or
                "uint" or "ulong" or "ushort" or
                "float" or "double" or "decimal" or
                "bool" or "char" or
                "DateTime" or "DateOnly" or "TimeOnly" or "Guid" or "TimeSpan"
                    => true,
                _ => typeName.EndsWith("?")
            };
        }

        /// <summary>
        /// Escapes XML documentation text.
        /// </summary>
        private string EscapeXmlDoc(string text)
        {
            if (string.IsNullOrEmpty(text))
                return string.Empty;

            return text.Replace("&", "&amp;")
                       .Replace("<", "&lt;")
                       .Replace(">", "&gt;")
                       .Replace("\"", "&quot;")
                       .Replace("'", "&apos;");
        }
    }
}
