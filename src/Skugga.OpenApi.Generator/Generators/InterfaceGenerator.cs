using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.OpenApi.Models;

namespace Skugga.OpenApi.Generator
{
    /// <summary>
    /// Generates C# interfaces from OpenAPI operations.
    /// Creates method signatures with proper parameters and return types.
    /// </summary>
    internal class InterfaceGenerator
    {
        private readonly OpenApiDocument _document;
        private readonly TypeMapper _typeMapper;
        private readonly bool _generateAsync;

        public InterfaceGenerator(OpenApiDocument document, TypeMapper typeMapper, bool generateAsync = true)
        {
            _document = document ?? throw new ArgumentNullException(nameof(document));
            _typeMapper = typeMapper ?? throw new ArgumentNullException(nameof(typeMapper));
            _generateAsync = generateAsync;
        }

        /// <summary>
        /// Generates a complete C# interface from OpenAPI paths.
        /// </summary>
        public string GenerateInterface(string interfaceName, string namespaceName, string? operationFilter = null, System.Collections.Generic.List<(string Name, string Modifiers)>? containingTypes = null)
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// This file is generated by SkuggaOpenApiGenerator");
            sb.AppendLine("// DO NOT EDIT: Changes will be overwritten on next build");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            // Namespace
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");

            // Generate containing type declarations if nested
            int nestingLevel = 1;
            if (containingTypes != null && containingTypes.Any())
            {
                foreach (var (name, modifiers) in containingTypes)
                {
                    var indent = new string(' ', nestingLevel * 4);
                    sb.AppendLine($"{indent}{modifiers} {name}");
                    sb.AppendLine($"{indent}{{");
                    nestingLevel++;
                }
            }

            // Interface declaration with XML doc
            var interfaceIndent = new string(' ', nestingLevel * 4);
            sb.AppendLine($"{interfaceIndent}/// <summary>");
            sb.AppendLine($"{interfaceIndent}/// Auto-generated interface from OpenAPI specification.");
            sb.AppendLine($"{interfaceIndent}/// Title: {EscapeXmlDoc(_document.Info?.Title ?? "API")}");
            sb.AppendLine($"{interfaceIndent}/// Version: {_document.Info?.Version ?? "1.0"}");
            sb.AppendLine($"{interfaceIndent}/// </summary>");
            sb.AppendLine($"{interfaceIndent}public partial interface {interfaceName}");
            sb.AppendLine($"{interfaceIndent}{{");

            // Generate methods from operations
            var operations = GetOperations(operationFilter);

            foreach (var (operation, path, method) in operations)
            {
                GenerateMethod(sb, operation, path, method, nestingLevel);
                sb.AppendLine();
            }

            // Close interface
            sb.AppendLine($"{interfaceIndent}}}");

            // Close containing types if nested
            if (containingTypes != null && containingTypes.Any())
            {
                for (int i = containingTypes.Count - 1; i >= 0; i--)
                {
                    nestingLevel--;
                    var indent = new string(' ', nestingLevel * 4);
                    sb.AppendLine($"{indent}}}");
                }
            }

            // Close namespace
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Generates a single method signature from an OpenAPI operation.
        /// Generates rich XML documentation for IDE IntelliSense.
        /// </summary>
        private void GenerateMethod(StringBuilder sb, OpenApiOperation operation, string path, string httpMethod, int nestingLevel = 1)
        {
            var indent = new string(' ', (nestingLevel + 1) * 4);
            var methodName = GetMethodName(operation, path, httpMethod);
            var returnType = GetReturnType(operation);
            var parameters = GetParameters(operation);

            // Rich XML documentation with HTTP details
            sb.AppendLine($"{indent}/// <summary>");
            var summary = operation.Summary ?? $"{httpMethod.ToUpper()} {path}";
            sb.AppendLine($"{indent}/// {EscapeXmlDoc(summary)}");
            sb.AppendLine($"{indent}/// </summary>");

            // Description with HTTP endpoint info
            sb.AppendLine($"{indent}/// <remarks>");
            if (!string.IsNullOrEmpty(operation.Description))
            {
                sb.AppendLine($"{indent}/// <para>{EscapeXmlDoc(operation.Description)}</para>");
                sb.AppendLine($"{indent}/// <para></para>");
            }

            // HTTP endpoint info
            sb.AppendLine($"{indent}/// <para><strong>Endpoint:</strong> {httpMethod.ToUpper()} {EscapeXmlDoc(path)}</para>");

            // Operation ID if present
            if (!string.IsNullOrEmpty(operation.OperationId))
            {
                sb.AppendLine($"{indent}/// <para><strong>Operation ID:</strong> {EscapeXmlDoc(operation.OperationId)}</para>");
            }

            // Tags if present
            if (operation.Tags != null && operation.Tags.Any())
            {
                var tags = string.Join(", ", operation.Tags.Where(t => t != null && !string.IsNullOrEmpty(t.Name)).Select(t => t.Name));
                if (!string.IsNullOrEmpty(tags))
                {
                    sb.AppendLine($"{indent}/// <para><strong>Tags:</strong> {EscapeXmlDoc(tags)}</para>");
                }
            }

            // Security/Auth requirements
            if (operation.Security != null && operation.Security.Any())
            {
                var securitySchemes = new List<string>();
                foreach (var secReq in operation.Security)
                {
                    foreach (var scheme in secReq.Keys)
                    {
                        if (scheme != null && scheme.Reference != null && !string.IsNullOrEmpty(scheme.Reference.Id))
                        {
                            securitySchemes.Add(scheme.Reference.Id);
                        }
                    }
                }
                if (securitySchemes.Any())
                {
                    sb.AppendLine($"{indent}/// <para><strong>ðŸ”’ Authentication:</strong> {string.Join(", ", securitySchemes.Distinct())}</para>");
                }
            }

            // Response documentation
            if (operation.Responses != null && operation.Responses.Any())
            {
                sb.AppendLine($"{indent}/// <para></para>");
                sb.AppendLine($"{indent}/// <para><strong>Responses:</strong></para>");
                sb.AppendLine($"{indent}/// <list type=\"bullet\">");

                foreach (var response in operation.Responses.OrderBy(r => r.Key))
                {
                    var statusCode = response.Key;
                    var statusDesc = response.Value?.Description ?? GetStatusCodeDescription(statusCode);
                    sb.AppendLine($"{indent}///   <item><strong>{statusCode}:</strong> {EscapeXmlDoc(statusDesc)}</item>");
                }

                sb.AppendLine($"{indent}/// </list>");
            }

            sb.AppendLine($"{indent}/// </remarks>");

            // Parameter documentation with enhanced details
            foreach (var param in parameters)
            {
                var paramDoc = EscapeXmlDoc(param.Description);
                if (string.IsNullOrEmpty(paramDoc))
                {
                    paramDoc = param.Name == "body" ? "Request body" : $"The {param.Name} parameter";
                }
                sb.AppendLine($"{indent}/// <param name=\"{param.Name}\">{paramDoc}</param>");
            }

            // Return value documentation
            var returnDoc = GetReturnDocumentation(operation, returnType);
            if (!string.IsNullOrEmpty(returnDoc))
            {
                sb.AppendLine($"{indent}/// <returns>{returnDoc}</returns>");
            }

            // Example usage
            var example = GenerateExampleUsage(methodName, parameters, returnType);
            if (!string.IsNullOrEmpty(example))
            {
                sb.AppendLine($"{indent}/// <example>");
                sb.AppendLine($"{indent}/// <code>");
                foreach (var line in example.Split('\n'))
                {
                    sb.AppendLine($"{indent}/// {line}");
                }
                sb.AppendLine($"{indent}/// </code>");
                sb.AppendLine($"{indent}/// </example>");
            }

            // Method signature with async support
            var isAsync = ShouldBeAsync(operation);
            var finalReturnType = isAsync && returnType != "void" ? $"Task<{returnType}>" :
                                  isAsync ? "Task" : returnType;

            sb.Append($"{indent}{finalReturnType} {methodName}(");

            if (parameters.Any())
            {
                sb.Append(string.Join(", ", parameters.Select(p =>
                    $"{p.Type} {p.Name}")));
            }

            sb.AppendLine(");");
        }

        /// <summary>
        /// Generates return value documentation from operation responses.
        /// </summary>
        private string GetReturnDocumentation(OpenApiOperation operation, string returnType)
        {
            if (returnType == "void")
                return "No content returned";

            var successResponse = operation.Responses?.FirstOrDefault(r =>
                r.Key == "200" || r.Key == "201" || r.Key == "202" || r.Key == "204" || r.Key == "default").Value;

            if (successResponse != null && !string.IsNullOrEmpty(successResponse.Description))
            {
                return EscapeXmlDoc(successResponse.Description);
            }

            return $"Returns {returnType}";
        }

        /// <summary>
        /// Generates example usage code for the method.
        /// </summary>
        private string GenerateExampleUsage(string methodName, List<ParameterInfo> parameters, string returnType)
        {
            var sb = new StringBuilder();
            var hasReturn = returnType != "void";

            // Example variable declarations for parameters
            if (parameters.Any())
            {
                foreach (var param in parameters.Take(3)) // Limit to first 3 for brevity
                {
                    if (param.Type.Contains("string"))
                    {
                        sb.AppendLine($"var {param.Name} = \"example-{param.Name}\";");
                    }
                    else if (param.Type.Contains("int"))
                    {
                        sb.AppendLine($"var {param.Name} = 123;");
                    }
                    else if (param.Name == "body" || !param.Type.Contains("?"))
                    {
                        sb.AppendLine($"var {param.Name} = new {param.Type.TrimEnd('?')}();");
                    }
                }
            }

            // Example method call
            var paramList = string.Join(", ", parameters.Select(p => p.Name));
            if (hasReturn)
            {
                sb.AppendLine($"var result = await api.{methodName}({paramList});");
            }
            else
            {
                sb.AppendLine($"await api.{methodName}({paramList});");
            }

            return sb.ToString().TrimEnd();
        }

        /// <summary>
        /// Gets a human-readable description for HTTP status codes.
        /// </summary>
        private string GetStatusCodeDescription(string statusCode)
        {
            return statusCode switch
            {
                "200" => "Success",
                "201" => "Created",
                "202" => "Accepted",
                "204" => "No Content",
                "400" => "Bad Request - Invalid parameters",
                "401" => "Unauthorized - Authentication required",
                "403" => "Forbidden - Insufficient permissions",
                "404" => "Not Found",
                "409" => "Conflict - Resource already exists",
                "422" => "Unprocessable Entity - Validation failed",
                "429" => "Too Many Requests - Rate limit exceeded",
                "500" => "Internal Server Error",
                "502" => "Bad Gateway",
                "503" => "Service Unavailable",
                "504" => "Gateway Timeout",
                "default" => "Default response",
                _ => statusCode
            };
        }

        /// <summary>
        /// Generates a method name from operation ID or path/method.
        /// </summary>
        private string GetMethodName(OpenApiOperation operation, string path, string httpMethod)
        {
            if (!string.IsNullOrEmpty(operation.OperationId))
            {
                // Convert operationId to PascalCase if needed
                return ToPascalCase(operation.OperationId);
            }

            // Generate from HTTP method + path
            var cleanPath = path.Replace("/", "_").Replace("{", "").Replace("}", "").Trim('_');
            return ToPascalCase($"{httpMethod}_{cleanPath}");
        }

        /// <summary>
        /// Determines if an operation should be async based on configuration.
        /// </summary>
        private bool ShouldBeAsync(OpenApiOperation operation)
        {
            return _generateAsync;
        }

        /// <summary>
        /// Gets the return type for an operation (unwrapped, Task wrapper added separately).
        /// </summary>
        private string GetReturnType(OpenApiOperation operation)
        {
            // Check for successful response codes (2xx)
            var successResponse = operation.Responses?.FirstOrDefault(r =>
                r.Key == "200" || r.Key == "201" || r.Key == "202" || r.Key == "204" || r.Key == "default").Value;

            if (successResponse == null)
                return "void";

            // Try multiple JSON content types in order of preference
            // 1. application/json (standard)
            // 2. application/*+json (e.g., application/vnd.api+json)
            // 3. text/json (legacy)
            // 4. Any content type with "json" in the name
            // 5. First content type with a schema (fallback for Swagger 2.0 conversion)
            var content = successResponse.Content?.FirstOrDefault(c => c.Key == "application/json").Value
                ?? successResponse.Content?.FirstOrDefault(c => c.Key.StartsWith("application/") && c.Key.EndsWith("+json")).Value
                ?? successResponse.Content?.FirstOrDefault(c => c.Key == "text/json").Value
                ?? successResponse.Content?.FirstOrDefault(c => c.Key.Contains("json")).Value
                ?? successResponse.Content?.FirstOrDefault(c => c.Value?.Schema != null).Value;

            if (content?.Schema == null)
                return "void";

            var bodyType = _typeMapper.MapType(content.Schema);

            // Check if response has headers - if so, wrap in ApiResponse<T>
            if (successResponse.Headers != null && successResponse.Headers.Any())
            {
                return $"Skugga.Core.ApiResponse<{bodyType}>";
            }

            return bodyType;
        }

        /// <summary>
        /// Gets parameters for an operation, including request body.
        /// </summary>
        private List<ParameterInfo> GetParameters(OpenApiOperation operation)
        {
            var result = new List<ParameterInfo>();

            // Add path and query parameters first
            if (operation.Parameters != null)
            {
                foreach (var param in operation.Parameters)
                {
                    var paramType = param.Schema != null
                        ? _typeMapper.MapType(param.Schema, null, !param.Required)
                        : "object";

                    result.Add(new ParameterInfo
                    {
                        Name = ToCamelCase(param.Name),
                        Type = paramType,
                        Description = param.Description ?? ""
                    });
                }
            }

            // Add request body parameter last (POST/PUT/PATCH)
            if (operation.RequestBody != null)
            {
                var content = operation.RequestBody.Content?.FirstOrDefault(c => c.Key.Contains("json")).Value;
                if (content?.Schema != null)
                {
                    var bodyType = _typeMapper.MapType(content.Schema, null, !operation.RequestBody.Required);
                    result.Add(new ParameterInfo
                    {
                        Name = "body",
                        Type = bodyType,
                        Description = operation.RequestBody.Description ?? "Request body"
                    });
                }
            }

            return result;
        }

        /// <summary>
        /// Gets all operations from the document, optionally filtered by tags.
        /// </summary>
        private List<(OpenApiOperation Operation, string Path, string Method)> GetOperations(string? operationFilter)
        {
            var result = new List<(OpenApiOperation, string, string)>();

            if (_document.Paths == null)
                return result;

            foreach (var path in _document.Paths)
            {
                // Check if path.Value or path.Value.Operations is null
                if (path.Value == null || path.Value.Operations == null)
                    continue;

                foreach (var operation in path.Value.Operations)
                {
                    var op = operation.Value;

                    // Skip if operation is null
                    if (op == null)
                        continue;

                    // Apply tag filter if specified
                    if (operationFilter != null)
                    {
                        var filterTags = operationFilter.Split(',')
                            .Select(t => t.Trim().ToLowerInvariant())
                            .ToArray();

                        if (op.Tags == null || op.Tags.Count == 0 || !op.Tags.Any(t =>
                            t != null && t.Name != null && filterTags.Contains(t.Name.ToLowerInvariant())))
                        {
                            continue;
                        }
                    }

                    result.Add((op, path.Key, operation.Key.ToString().ToLower()));
                }
            }

            return result;
        }

        /// <summary>
        /// Converts a string to PascalCase.
        /// </summary>
        private string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            // If input is already PascalCase or camelCase (no delimiters), just ensure first char is uppercase
            if (!input.Contains('_') && !input.Contains('-') && !input.Contains(' '))
            {
                return char.ToUpperInvariant(input[0]) + (input.Length > 1 ? input.Substring(1) : "");
            }

            // Handle snake_case, kebab-case, space separated
            var parts = input.Split(new[] { '_', '-', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            var sb = new StringBuilder();

            foreach (var part in parts)
            {
                if (part.Length > 0)
                {
                    sb.Append(char.ToUpperInvariant(part[0]));
                    if (part.Length > 1)
                        sb.Append(part.Substring(1).ToLowerInvariant());
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Converts a string to camelCase.
        /// </summary>
        private string ToCamelCase(string input)
        {
            var pascal = ToPascalCase(input);
            if (string.IsNullOrEmpty(pascal))
                return pascal;

            return char.ToLowerInvariant(pascal[0]) + pascal.Substring(1);
        }

        /// <summary>
        /// Escapes XML documentation text.
        /// </summary>
        private string EscapeXmlDoc(string text)
        {
            if (string.IsNullOrEmpty(text))
                return string.Empty;

            return text.Replace("&", "&amp;")
                       .Replace("<", "&lt;")
                       .Replace(">", "&gt;")
                       .Replace("\"", "&quot;")
                       .Replace("'", "&apos;");
        }

        private class ParameterInfo
        {
            public string Name { get; set; } = string.Empty;
            public string Type { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
        }
    }
}
